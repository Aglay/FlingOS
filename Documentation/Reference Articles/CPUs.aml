<?xml version="1.0" encoding="utf-8"?>
<topic id="8e917313-26da-456f-91be-75ddf09a2acc" revisionNumber="1">
  <developerConceptualDocument xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5" xmlns:xlink="http://www.w3.org/1999/xlink">
    
    <introduction>
      <autoOutline>20</autoOutline>
    </introduction>
    
    <!--
    
    	Structure:
    		- Introduction
    			- Scope of this article
    			- How this article is structured
    			- [Section titles]
    		- CPU Architecture
	    		- Overview
	    			- Clarifying what a CPU is
	    			- What is meant by "architecture"?
	    			- What are some general differences between architectures?
	    			- What are the main effects of these differences?
	    			- Specific architecture examples
	    		- Intel / AMD x86 Architecture
	    			- Brief summary of key details
	    			- Why "Intel / AMD"?
	    			- Specification sources
	    			- 32-bit or 64-bit?
	    			- Links to x86 development tools
	    		- ARM Architecture
	    		 	- Brief summary of key details
	    		 	- Who?
	    		 	- Specification sources
	    		 	- 32-bit or 64-bit?
	    			- Links to ARM development tools
	    		- RISC vs CISC
	    			- Acronym meanings
	    			- Key differences between the two
	    			- Advantages of RISC
	    			- Advantages of CISC
	    			- Disadvantages of RISC
	    			- Disadvantages of CISC
	    			- Conclusion
	    		- ARM vs x86
	    			- Origins of the two
	    			- Drawing from RISC vs CISC
	    			- Advantages of ARM
	    			- Advantages of x86
	    			- Disadvantages of ARM
	    			- Disadvantages of x86
	    			- Conclusion    			
	    		- Assemblers Syntaxes
	    			- MASM, NASM, GAS
	    			- Inline assembler
	    		- NASM
	    			- Notes about NASM & Fling OS
	    			- A few NASM examples
	    			- Links
    		- CPUs As Devices
    			- Overview
    			- General features
    			 	- ID
    				- Halt / Reset
    				- Speed
    				- Multiple CPUs / Multicore
    			- x86
    				- ID
    				- Halt
    				- Reset
    		- Tutorials
    		- Further Reading
    		- References
    		
    -->
        
    <!-- - - - - - - - - - - - - - - - -  Introduction  - - - - - - - - - - - - - - - - -->
    <!--
    
			Scope of this article
				This article covers two broad topics. The first is CPU Architecture. This provides an explanation of 
				what is meant by CPU Architecture followed by a discussion of general information. This is further
				followed by discussion of the main two CPU architectures developers are likely to be working with,
				namely, ARM and x86. A limited discussion of assembler programming is also included. 
				
				The second topic covered by this article is CPUs As Devices. This provides a different perspective
				on a CPU, looking at it from the OS developer's point of view once the kernel is running. It looks
				at the CPU as a device which must be managed and can be used to perform specific processor functions.
			
			How this article is structured
				This article is structured into the two sections described. These are further split into sub-sections
				which follow the general pattern presented here (where each item listed is only included in a given 
				sub-section if it is appropriate):
					1. Overview (of what the sub-section will discuss)
					2. General discussion
					3. Specific examples
					4. Discussion of selected specific examples
					5. One example vs. another
					6. Code examples
					7. Conclusion
					8. Links to useful resources
			
			[Section titles]
				
    -->
    
    <!-- - - - - - - - - - - - - - - - -  CPU Architecture  - - - - - - - - - - - - - - - - -->
    
    <!--
    
    		Overview
    			Clarifying what a CPU is
    				- Definition
    				The Central Processing Unit (CPU or just "processor" for short), is the primary piece of hardware 
    				which executes program instructions. A CPU performs the fundamental arithmetic, logic and input/
    				output operations required to manipulate data in a useful way.
    				
    				
    				- Explanation
    				The CPU acts as the "brains" of a computer system (be it a PC, tablet or mobile). Everything you
    				want to do, has to start somewhere in the CPU. In the simplest case, your PC would have only one
    				CPU, with one logical processing unit on that CPU. However, modern CPUs consist of multiple processing
    				units and modern PCs can contain multiple CPUs. It is probably helpful to think of a processing
    				unit as a CPU in its own right. While this is not strictly correct, it is sufficient to realise
    				that each processing units acts, in the simple cases, mostly independently of the other units. 
    				
    				A processing unit is a piece of hardware which (ignoring how it does the following) loads a set of
    				program instructions from memory and then executes each instruction sequentially, until either
    				reaching the end of those instructions or faulting. The instructions a CPU executes can be broken
    				down into 5 main categories:
    					- Data transfer 	: 	Ops for transferring data to/from memory or other devices.
    					- Arithmetic		: 	Add, subtract, multiply, divide and various other operations involving one or
    											more numbers.
    					- Logical			:	Bit-wise logical AND, OR, XOR, NOT and various other operations involving one
    											or more binary numbers.
    					- Control flow		:	Branch, jump, loop and various other ops which control which instructions get
    											executed next. 
    					- Other				:	A category which encompasses a wide range of ops from those which control
    											Interrupts to processor specific ops to binary shift/rotate ops.
    				
    				It is key to understand that everything a computer does can be made up of a combination of these 
    				types of operation. For instance, if you wish to multiply two numbers x and y together, you must
    				perform:
    					1. A data transfer op to load x from memory
    					2. A data transfer op to load y from memory
    					3. An arithmetic op to multiply x by y
    					4. A data transfer op to store the result
    				
    				Or, if you wish to load an element from an array you must perform:
    					1. A data transfer op to load the address of the start of the array
    					2. A data transfer op to load the index of the element to get
    					3. A data transfer op to load the size, in bytes, of each element in the array
    					4. An arithmetic op to multiply the index by the size to get the offset of the element from the start of 
    					   the array
    					5. An arithmetic op to add the offset to the address of the array
    					6. A data transfer op to load the value at the newly calculated address
    					7. A data transfer op to store the loaded value
    				
    				Of course, depending on your architecture, the above steps may or may not be optimised to fewer steps. 
    				None the less, the same basic operations are being performed. This will be further discussed in
    				later topics covering CPU Architectures.
    				
    				The key thing to take away from this explanation, is that a CPU executes instructions which control what
    				the computer does. It is we, humans, who assign meaning to the data passing through the CPU and how that
    				data is manipulated.
    				
    				
    				- As a target
    				The first perspective of a CPU that a developer must understand when developing an OS is that the CPU is
    				a target. You pick a particular CPU (or a particular group of CPUs) which you want your OS to run on. 
    				This is what you are targeting. Each CPU (or group of CPUs) will have its own set of features, its own
    				particular set of instructions and its own requirements from the OS. There is no one-size-fits-all way 
    				of programming the low-level parts of an OS. Once you settle on which CPU(s) to target, you must stick
    				to that choice until you at least get your basic kernel working. After that, you can consider porting
    				your code to other targets.
    				    	
    				    	
    				- As a device
    				The second perspective of a CPU that a developer will need to understand when developing an OS is that the
    				CPU is a device. It is a device as much as your mouse, keyboard and screen are devices. It requires 
    				managing while your OS is running. This management ranges from the very simple (like telling it where to 
    				get the next instruction from) to the very complex (such as managing multiple processing units). 
    				
    				While you could think of the CPU device as a target device - a device which your OS will support management
    				of - it would be a little unwise to do so. Thinking of it as a target would lead to the idea that methods
    				of management applied to one CPU, cannot be applied to another. This is not the case. If you were to write
    				a CPU manager to manage multiple processing units, you could probably use the same code on another CPU too.
    				The difference is that your compiler would need to target a different CPU. The code remains logically the 
    				same (i.e. the CPU as a device, remains logically the same) but the actual outputted instructions change to
    				the ones required for the specific CPU you targeted. 
    				
    				It is important to realise that the CPU as a target affects what the compiler produces. The CPU as a device
    				affects what you program. If you are programming in assembler, then clearly the target CPU will also affect
    				what you program but the logic of what you program can (usually) remain the same. 
    				
    				For more information about the CPU as a device, see "CPUs As Devices" sections further down in this article.
    				    	
    				    	
    			What is meant by "architecture"?
    				- Definition
    				A CPU architecture is a CPU design (but this statement is hardly any help). A CPU architecture lays out
    				designs for every aspect of the CPU. What this encompasses, of course, varies from CPU to CPU, which makes
    				a definition rather difficult. However, we can say the following. A CPU architecture usually encompasses the 
    				following designs / specifications:
    					- Instruction Set
    					- Hardware features (e.g. registers, virtual memory)
    					- Software conventions (e.g. register uses)
    				    		
    				    		
    				- Explanation
    				Looking at these areas in more detail:
    					- Instruction set - This is the set of assembler ops. This has been mentioned and detailed before in 
    										"Clarifying what a CPU is - Explanation". The CPU instructions and the instruction
    										set are (to all intents and purposes) the same thing. The instruction set lays out
    										precisely what each operation does, any side effects and any required or optional
    										parameters (often in the form of registers) to the op. The instruction set also
    										defines the identifiers for the registers available in the CPU.
    					- Hardware features - The hardware features define what the CPU is capable of doing. This ranges from
    										  what registers are available (and for what purposes) through to how IO ports are 
    										  accessed through to how the Memory Management Unit is controlled. The basic 
    										  hardware features of CPUs are fairly similar across all CPUs these days meaning
    										  you need only really learn the instruction set to find out how to begin programming
    										  the basics. More complex features obviously begin to vary a lot as that is what sets 
    										  different CPUs apart.
    					- Software features - The software features define how the CPU designers expect it to be used (and may
    										  also impose some practical restrictions that the compiler or hardware enforce.)
    										  For example, software features might include specifying which registers
    										  should be used for return values from a function call. This isn't necessarily 
    										  enforced by anything so in theory  you could probably work against the software 
    										  design features but you'd be foolish to do so. The designers probably knew what
    										  they were talking about! What is defined in the software features varies wildly
    										  and whether you have to stick to them is also variable. You will always have to
    										  read the specs for your specific target architecture to find out what they say 
    										  for this section.
    				
    				It is probably apparent that each of these areas is closely linked to the other. For example, the specific 
    				hardware registers each have names which are then used in the instruction set. Register uses are sometimes 
    				strictly defined which also sets out which instructions can be used thus further defining the instruction set. 
    				Thoroughly understanding your target CPU's architecture will put you in a good stead when it comes to 
    				programming the first bits of code related to booting your OS and initialising the CPU.
    				
    				
    				- Alternative uses
    				It should also be noted that the term "CPU architecture" may be used in other contexts for example hardware
    				engineers may use it to refer to the precise design and layout of one particular CPU and ignore the software
    				features entirely.
    				
    				
    			What are some general differences between architectures?
    				- Little vs. big endian
    				A fundamental difference between architectures is whether they are little or big endian. This is something which
    				often trips people up when converting examples between architectures. Little and big endian refer to the order
    				in which the most to least significant bytes are stored in memory. In short, little endian means the least 
    				significant byte is stored at the lower address. Big endian means the most significant byte is stored at the 
    				lower address. For a fuller explanation, please see the following articles:
    					- http://en.wikipedia.org/wiki/Endianness
    					- http://www.cs.umd.edu/class/sum2003/cmsc311/Notes/Data/endian.html
    				  (All links were valid as of 10-09-2014)
    				
    				- Register sizes
    				Another common difference between architectures is register sizes. The maximum register size will affect 
    				(and possibly limit) that largest number of bytes you can operate on in one operation. You can expect that 
    				in a 32-bit architecture, the largest CPU register (not FPU register) will be 32-bits wide. Similarly, in a 
    				64-bit architecture the largest CPU register is likely to be 64-bits wide. (This may not always hold true but 
    				it is a reasonable rule of thumb.) Most general purpose registers are also subdivided into smaller registers 
    				that are 16 and 8 bits wide. For example, on x86 the primary (A) general purpose register can be accessed as 
    				follows:
    					- EAX = 32-bits wide
    					-  AX = 16-bits wide, Lower 16-bits of EAX
    					-  AL =  8-bits wide, Lower  8-bits of  AX
    					-  AH =  8-bits wide, Higher 8-bits of  AX
    				
    				- Register uses
    				What uses registers are assigned to varies depending on what features a CPU is attempting to support. All CPUs
    				(with perhaps the exception of some specialist units) have general purpose registers that are used for any 
    				purpose the programmer desires. CPUs then have various special purpose registers. The following are possible
    				examples of some:
    					- FPU registers - used by the floating point units (FPUs) for floating point calculations
    					- Segment registers - used by the CPU for managing segmented memory 
    					- Descriptor registers - used by the CPU to store / load the address of descriptors tables used to provide
    											 data / guidance (not really instructions) to the CPU on how to process things. 
    											 For example, these contain the Interrupts Descriptor Table which provides interrupt
    											 function addresses.
    					- Processor registers - used by the CPU for managing the current program execution. For example, the stack,
    											base and current instruction pointers.
    					- Many more...but you will come across these as you explore the architecture you pick.
    				
    				- Hardware access e.g. IO Ports
    				Another key difference between architectures is how you access other parts of the hardware, be they part of the
    				motherboard or attached via sockets. The FPU and MMU are now often part of the CPU hardware and are accessed
    				simply by using special registers and special CPU instructions. However, there are a number of standards for 
    				communication with attached devices, such as PCI(e) (on top of which also sits USB) and SATA (for hard-drives). 
    				However, both of these standards, along with many others work somewhat independently of how data is actually 
    				transferred to and from the CPU and the data buses. In general, this transfer mechanism is called an IO Port. 
    				How IO Ports operate from the CPU's perspective depends upon the CPU and motherboard architecture. As an example, 
    				the x86 architecture offers the ability to map IO ports to particular memory addresses. You then use the special 
    				in/out operations to respectively write / read the ports. (Note: x86 also has memory mapped registers where data 
    				buses are mapped directly to address ranges but this is a further form of IO port system.)
    				
    				- Memory management
    				As has been mentioned briefly previously, memory management also varies. Older CPU architectures used a 
    				segmented virtual memory system but modern CPUs most often use a paged memory system. The advantages and
    				disadvantages of the two are beyond the scope of this article. However, it should be noted that which
    				option is supported by your target CPU (or possibly both options e.g. x86) can have a big impact on your 
    				OS design.
    				
    				- Instruction sets
    				As has been discussed in detail previously, the instruction set of a CPU architecture is very particular to
    				precisely what the CPU supports. Hence, it varies from CPU to CPU. However, as you will see later in this 
    				article, the same basic set of instructions can be used across a wide range of CPUs. This will be discussed 
    				in more depth later.
    			
    			What are the main effects of these differences?
    				There are several effects of these differences which are covered briefly below, though an in depth discussion
    				of the good / bad aspects of every difference would take more words than it is worth. You need only note
    				the general points to be able to make a reasonably informed decision about which architecture you choose.
    				
    				- Ease of learning / Ease of use
    				The more specialist the CPU architecture you target, the harder it will be to learn. This is for several, broad
    				reasons:
    					1. The instruction set is (probably) very specific / specialist which will reduce the likelihood of the being
    					   resources freely available online
    					2. Specialist hardware means specialist knowledge and probably a load of standards nobody has ever heard of. 
    					   This further reduces the likelihood of there being a good pool of resources available to you.
    					3. Specialist means just that, specialist. It is likely that you will not be able to port code or concepts 
    					   from other architectures to help you, so you will be very much alone.
    					   
    				On the plus side, specialist CPUs are less and less common and for the average (haha!) OS developer, you need
    				only target popular architectures such as x86 and ARM. (Note: x86 and ARM architectures are discussed in more
    				detail later.)
    				    				
    				- Power consumption
    				The larger the instruction set, the more hardware will be required to support the instructions. In general this
    				means more physical silicon which in turn means a higher power consumption. This is broadly the history of the
    				battle between the ARM and Intel architectures but this will be discussed in more detail later. Either way,
    				the architecture you choose to support will have a big impact on the CPU power consumption. If you are 
    				programming for an embedded environment (such as watches or phones), this is a big deciding factor.
    				
    				- Speed
    				Larger instruction sets, more specialist ops, more registers, more sophisticated memory management, etc. All of 
    				these things will, if properly and fully utilised, make your OS run much faster. However, you will certainly
    				spend a lot longer developing your OS, as you will have to spend time optimising it here, there and everywhere
    				to gain the full benefit of the aforementioned features. So what you gain in runtime speed, you pay for massively
    				in development speed.
    				
    				- Compiler complexity
    				You probably don't care about this, unless you are planning on writing your own compiler (a task which is 
    				considered as challenging as writing an OS!) A large instruction set or specialist ops or few general purpose
    				registers will make writing a good compiler more challenging. This is because your compiler will have to pay
    				much closer attention to what is happening to the data and how/when it can use specialist ops or reuse registers.
    				A discussion of compiler design is not included in the Fling OS articles but given the existence of GCC, MSBuild
    				and numerous other open-source compilers for just about every language, you should be able to find one that 
    				works for you somewhere.
    			
    			Specific architecture examples
    				A few examples of widely available / well known architectures:
    			 	- x86 (inc. 32 and 64 bit versions)
    			 	- ARM (inc. 32 and 64 bit variants)
    			 	- MIPS (3)
    			 	- PowerPC
    			 	
    			 	A fuller list (by name) can be found at: http://en.wikipedia.org/wiki/Comparison_of_instruction_set_architectures
    			 	(Link valid as of 10-09-2014.)
    			
    			Final note before we move on
    				I should note at this point that I have talked very much as though you have a choice over the CPU architecture
    				you choose to target. This is possibly helpful and misleading at the same time. In most cases you will be forced
    				to target the CPU architecture you have available to you. That is likely to be either your development machine's
    				architecture (most likely x86) or the architecture of a development device such as the Raspberry Pi (ARM).
    				If you plan on creating your own custom set of hardware (which may be possible with Google's initiatives in
    				plug-and-play designs) then you are in the fortunate position of truly deciding for yourself!
    
    -->
    
    <!--
    
    		Intel / AMD x86 Architecture
	    		Brief summary of key details
	    			- Origin - Intel 
	    			
	    			**************************** THIS LINK IS INVALID ***************************
	    			REMOVE THE SPACE IN "timeline- -"
	    			http://www.computerworld.com/article/2535019/computer-hardware/timeline- -a-brief-history-of-the-x86-microprocessor.html
	    			
	    			
	    			****************************************** CHECK THIS ******************************************
	    			
	    			The x86 architecture originates from the first Intel 8086 CPU (which itself was a 16-bit redesign of the 8008 
	    			and 8080 CPUs). The 8086 was a 16-bit CPU but later designs extended the x86 architecture to 32-bit and then
	    			64-bits. AMD also adopted the architecture for their CPUs and did the work to extend the instruction set to 
	    			64-bits (which Intel later re-adopted). Thus has led to the instruction set being known as the Intel / AMD x86 
	    			Instruction Set since the (non-processor-model-specific) set of instructions has been co-specified by the two 
	    			companies. Compilers often refer to the x86 32-bit architecture as IA32 and x86 64-bit as AMD64 as these are
	    			the original / official names for the two architectures.
	    			
	    			****************************************** CHECK THIS ******************************************
	    			
	    			- A lot of history = a lot of baggage (see CISC and Segmented memory)
	    			The x86 processor is steeped in history and, because it has always been backwards compatible, the
	    			architecture contains some outdated features that are no longer used. Examples include segmented virtual memory
	    			which, in the majority of new OS'es, has been replaced with paged virtual memory. You should also note that 
	    			x86 64-bit processors are fully compatible with 32-bit assembly code. So if you build an x86 32-bit OS, it will
	    			also run on x86 64-bit processors. This is useful when considering testing on modern PCs which now mostly come 
	    			with 64-bit processors.
	    			
	    			- Standard for PCs
	    			x86 processors have long been the standard processor architecture PCs since Windows is built for the x86. Linux
	    			now also has many builds for x86. Consequently, if you build an OS targeting x86 (32-bit) you will be able to
	    			test it on almost any PC you find. (Though you may have issues with BIOS/UEFI/alternatives that prevent your OS
	    			booting, but that is different issue.)
	    			
	    			- Now standard for Macs
	    			The architecture has become so solidly associated with PCs that Apple switched Macs from PowerPC to x86 to 
	    			increase compatibility. (Note: Apple fan-boys may never admit that Apple gave in to the PC on processor architecture, 
	    			but that's mostly a matter of opinion and not one which I care about much...)
	    				    			
	    			- Complex instruction set (see CISC)
	    			x86 follows a CISC (Complex Instruction Set Computing) design. For more information on what this means and its
	    			impact, please see later in this article.
	    			
	    			- Few general purpose registers
	    			The x86 architecture has only 4 general purpose registers (which themselves have specialist purposes depending on
	    			the specific op). It also has a fair few specialist registers. Many vs. few general purpose registers is discussed 
	    			more later. The x86 general purpose registers are called A, B, C and D. They have been mentioned previously in 
	    			"General Differences Between Architectures : Register Sizes". The names of the different sized versions are listed 
	    			below:
	    					Lo 8-bits		Hi 8-bits		Lo 16-bits		(Lo) 32-bits		64-bits (if x64)
	    						AL				AH				AX				EAX					 RAX
	    						BL				BH				BX				EBX					 RBX
	    						CL				CH				CX				ECX					 RCX
	    						DL				DH				DX				EDX					 RDX
	    			
	    			These registers can be used for anything broadly you like except when you use specific ops (for example the "loop"
	    			op). 		
	    			
	    			- Little endian
	    			Please note that the x86 architecture is always little endian.
	    			
	    			- Traditionally, high power consumption
	    			The x86 architecture, as created by Intel and AMD, has traditionally had high power consumption which is largely
	    			the reason it has dominated the PC market but not penetrated the mobile or tablet markets. The reasons for its 
	    			higher power consumption are discussed later in RISC vs CISC. However, since the x86 architecture is high power:
	    				1. You (in my opinion) needn't trouble yourself too much with writing super-optimised code the first couple 
	    				   of times you try. You should focus more on readability and maintainability. The power of the CPU and the 
	    				   compiler will probably do a better job than any optimisations you try and add. 
	    				2. You (in my opinion) needn't spend hours supporting power optimisations for devices (such as sleep mode in
	    				   USB). You are likely to spend a lot of time programming for no real benefit (even if you are targeting
	    				   laptops - you are more likely to benefit from writing more useful drivers than power optimised ones!)
	    			
	    			- Easiest to learn 32-bit
	    			It is advisable to learn the 32-bit x86 instruction set and use it extensively before you start on the 64-bit 
	    			version. The 32-bit version is complex enough with enough specialist ops let alone the 64-bit version. The 64-bit
	    			version adds more specialist ops, extended registers and, if you adhere to the design advise closely, an annoyingly
	    			complicated calling convention (by comparison to the 32-bit version).
	    			
	    			- High number of resources and examples for x86
	    			The x86 architecture has a significantly large number of resources (especially by comparison to ARM). As an OS
	    			developer this will be vital. Additionally, Fling OS currently only targets x86 so all resources and examples are 
	    			written from an x86 perspective. 
	    			
	    			- Easy to test
	    			Since the x86 architecture is so prolific in PCs, testing code written for it is very easy. Real hardware is
	    			widely available and USB boot sticks are easy to create and update. Furthermore, virtual machines work on the same 
	    			architecture as the host PC and, since most PCs have x86 in them, you can test x86 code on most PCs. Also, x86 
	    			emulators for Windows, Linux and Mac are widely available. Both virtual machines and emulators are freely available 
	    			such as VMWare Player, Virtual Box and Qemu.
	    			
	    			- If you have any additional useful information (or just header titles)
	    			Please submit them for addition.
	    			
	    			- CISC architecture
	    			As has been mentioned several times previously, x86 is synonymous with CISC architecture design. More information
	    			about the theory behind CISC and a comparison to RISC is provided later in this article.
	    		
	    		Specification sources
	    			Links valid as of 2014-09-16
	    			- Intel x86 specs : http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html
	    			- x86 Instruction set listings : http://en.wikipedia.org/wiki/X86_instruction_listings#Added_with_80386
	    			- x86 Instruction set reference site : http://en.wikibooks.org/wiki/X86_Assembly
	    		
	    		32-bit or 64-bit?
	    		 	When deciding which version of the architecture to target, there are a few aspects to consider (most of which have 
	    		 	been mentioned at least briefly before):
	    		 	- 32-bit : Easiest to learn	    		 	
	    		 	- 32-bit : Maximum compatibility
	    		 	- 32-bit : Has simpler calling convention (if you follow design / spec advice)
	    			- 64-bit : Once you are very advanced or if you have special purposes
	    		 	- 64-bit : Adds a lot of complexity so only use it if you will really reap the benefits
	    		 	
	    		Links to x86 development tools
	    			Links valid as of 2014-09-16
	    			- NASM compiler : http://www.nasm.us/
	    			- Virtual machines (if running on x86 hardware):
	    				- VMWare Player : https://my.vmware.com/web/vmware/free#desktop_end_user_computing/vmware_player/6_0
	    				- VirtualBox : https://www.virtualbox.org/
	    			- Emulators (if not running on x86 hardware):
	    				- Qemu : http://wiki.qemu.org/
	    			
	    			Please note: At the time of writing, Fling OS primarily used VMWare Player for testing.
    
    -->
    
    <!--
    
    		ARM Architecture
    		 	Brief summary of key details
    		 		- Origin - ARM
    		 		The ARN architecture originates from the first ARM CPU created by Acorn Computers (the design team later became
    		 		what is now known as ARM Holdings). ARM was first created in 1985, the same year that the 32-bit version of x86 
    		 		was introduced (sources: Wikipedia, "ARM Architecture" and "x86" pages, as of 2014-09-16). Prior to what we know
    		 		as the ARM architecture, the ARM development team created the very successful CPU as part of the BBC Micro. ARM2
    		 		was the first ARM architecture CPU produced and became available in 1986. Since then, the architecture has gone
    		 		through a number of revisions but has broadly retained the simple instruction set and core design principles.
    		 		
    		 		- A lot of history = very little baggage (see RISC)
    		 		Despite ARMs long history, they have relatively little "baggage" in the architecture (unlike x86, for example). 
    		 		The ARM architecture has had three major advantages:
    		 			1. They had the opportunity to learn from the several years of mistakes that Intel and x86 had made
    		 			   with 16-bit to 32-bit changes and similar ideas.
    		 			2. The nature of the markets they were selling to (Apple, Mobile, embedded) meant they could afford to
    		 			   produce completely new revisions of the architecture which contained breaking changes compared to 
    		 			   previous architectures. This meant they could ditch some of the "baggage" along the way and so have a
    		 			   comparatively less cluttered architecture.
    		 			3. RISC design principles keep things simple. Since the ARM architecture was designed to have simple single-step
    		 			   instructions, every op is easy to understand and use. There is also less dependency between ops due to their
    		 			   simpler nature requiring less setup prior to the op. Consequently, the architecture has remained fairly easy 
    		 			   to understand and uncluttered.
    		 		
    		 		- Standard for embedded devices
    		 		ARM CPUs have become the standard for embedded, mobile and tablet devices, having a clear majority of the 
    		 		market in 2014. This is because of ARM CPUs' low-power, small-size and low-heat properties (which are a virtue
    		 		of the RISC design principles). It is also worth noting ARM was selected by the Raspberry Pi developers as their
    		 		CPU again for its low-cost, low-power, low-heat and high support by Linux. (There may be other reasons but these
    		 		are the obvious ones).
    		 		
    		 		- Simple instruction set (see RISC)
    		 		ARM is a RISC architecture (discussed later in this article) which means it has a simple instruction set
    		 		which makes it easy to learn, easy to write ASM for and easier to write a compiler for than its x86 32 and 64-bit 
    		 		counterparts. However, because of its simple (single-step) instructions, a lot more operations must be performed to 
    		 		complete the same task (in comparison to an equivalent implementation on a CISC architecture such x86). This is 
    		 		discussed in more detail in RISC vs CISC later in this article.
    		 		
    		 		- Lots of general purpose registers
    		 		The ARM architecture has a lot of general purpose registers, some of which are grouped into slightly more specific
    		 		uses. This is useful to assembler programmers and compiler programmers as it offers a lot of freedom when writing
    		 		code. This reduces headaches when writing code, in comparison to x86, as less must be placed on the stack as 
    		 		temporarily storage. This, in turn, improves performance as register access is, generally, faster than memory
    		 		access.
    		 		
    		 		- Paged virtual memory - CHECK THIS
    		 		There are many variations of the ARM architecture since ARM have produced many CPUs for many different environments.
    		 		However, the main 32 and 64-bit ones aimed at mobile, tablet, laptop and desktop computing support paged virtual 
    		 		memory. Note: This may not be true in all cases but it's a reasonable guide. If you think this is a bad guide, please
    		 		let me know and suggest alternative, more accurate information.
    		 		
    		 		- What endianness?
    		 		As mentioned in the previous section, there have been many variations of the ARM architecture. The endianness is
    		 		model specific and so is classed as variable. You should try to write your code in a generic way so far as possible.
    		 		When it is not possible, you will need to check the model of CPU on which you intend to test (/run) your code.
    		 		    		 		
    		 		- 64-bit is simple extension of 32-bit so easy to learn either
    		 		Due to the simplicity of the RISC architecture, 64-bit is a simple extension of the 32-bit version which makes learning
    		 		the 32 and 64-bit version equally easy. This is very different from, for example, the x86 architecture. This gives
    		 		ARM an advantage over x86 from a developer's perspective.
    		 		
    		 		- Fewer resources and examples for ARM
    		 		Despite the ease of learning, ARM has far fewer resources for hobby developers. This is probably due to the fact 
    		 		that x86 is easier to develop for, so hobby OS'es target x86 so resources are created for x86 development. This
    		 		is somewhat of a perpetual cycle which ever reinforces the x86 development resources. ARM, however, have caught 
    		 		a lucky break with the Raspberry Pi including it, forcing lots of developers to reconsider their choice. Combined
    		 		with the growing mobile and tablet markets, which largely contain ARM, (hobby) developers are slowly shifting focus
    		 		to ARM from x86.
    		 		
    		 		- Harder to test 
    		 		ARM is significantly harder to test on for three primary reasons:
    		 			1. ARM-based hardware is pretty hard to get hold of cheaply (ignoring the exceptional Raspberry Pi).
    		 			2. Without ARM hardware, you are stuck with using emulators not VMs which are slow and less convenient to use.
    		 			3. Since every ARM processor is different and not all are ASM compatible, you have to develop for one specific
    		 			   branch of processors which is more constraining than x86.
    		 		(Also, it's a lot cooler to be able to boot your OS on anyone's PC than messing around with (and probably damaging)
    		 		 their phone.)
    		 		
    		 		- RISC Architecture
    		 		As has been mentioned, the ARM processor is a RISC architecture, which is discussed in more detail later.
    		 		
    			Links to ARM development tools
    				- An reference book for ARM assembler?
    				- Qemu and/or other emulators for ARM?
    				- NASM or other compilers depending on whether they support ARM?
    			
    
    -->
    
    <!--
    
    		RISC vs CISC
    			Acronym meanings
	    			Reduced Instruction Set Computing (RISC) and Complex Instruction Set Computing (CISC) are opposing design ideologies
	    			applied to the design of computer architecture. 
	    			
	    			RISC follows the general principle of defining as simple instructions as possible to keep each instruction single-step
	    			making them run very fast. CISC, however, follows the general principle of defining multi-step, specialist ops wherever 
	    			possible to create a complex but fast instruction set. There are no precise definitions of what constitutes RISC and 
	    			CISC nor where the boundary between them lies. The two concepts are best understood in tandem by comparing their
	    			differences.
	    			
	    			Examples of RISC designs are ARM processors. An example of CISC design is the x86 processor. ARM vs. x86 is a very 
	    			similar but subtly different debate discussed after this RISC vs. CISC debate.
	    			
    			Key differences between the two
    				(Please note: op = operation = instruction)
    			
    				- RISC ops are single-step, CISC ops are multi-step
    				RISC operations are single-step meaning they only do one thing such as a single load from memory or a single
    				numerical operation like add. CISC operations are multi-step meaning they do complex processes such as
    				load a value from memory, add it to a register and store the result all in one overall operation.
    				
    				- RISC ops require fewer clock cycles than CISC ops
    				CISC ops are multi-step so take longer to run with more sub-operations than RISC's single-step ops. This
    				means CISC ops take more clock cycles to run than RISC ops.
    				
    				- CISC ops accomplish more
    				CISC ops are multi-step so complete more in one single operation than a single RISC op. This means fewer
    				CISC ops are required to complete an overall task than the equivalent required RISC ops. This offsets the
    				extra time a single CISC op takes compared to a RISC op. The two designs are a trade-off between instruction
    				speed and instruction efficiency. This has been neatly summarised by this equation:
    				
    					(time / program) = (time / instruction) * (instructions / program)
    				
    				(Adapted from http://cs.stanford.edu/people/eroberts/courses/soco/projects/risc/risccisc/, 2014-09-16)
    				
    				- RISC ops require fewer transistors than CISC ops
    				A typical RISC op requires far fewer transistors (in hardware) than CISC ops because of their reduced 
    				design. This means RISC ops take up less physical silicon and less power (which also means, they create 
    				less heat).
    				    				
    				- RISC ops are (usually) encoded in a uniform format, CISC are not
    				Since RISC ops are all fairly simple, requiring a minimum of parameters, every op can be encoded in a small
    				amount of data thus meaning it is inexpensive to encode every op in the same amount of data. For example,
    				some ARM processors encode all operations as 32-bits of data. CISC operations use anything from 0 to many 
    				parameters and the nature of complex ops means that CISC tends to be encoded using a variable op-size format.
    				Overall, this means RISC uses more program data than CISC does due to:
    					1. Total size of the same number of RISC ops is, on average, slightly bigger then or the same as CISC ops
    					   (there is some debate on how to measure this).
    					2. Total number of ops for RISC is much greater than CISC (this is well-known and accepted) meaning the
    					   number of encoded ops is much greater so the total data size is much greater.
    				
    				- RISC has simple addressing modes, CISC has complex modes
    				RISC ops are simple, with only a few operations able to perform load / store operations. This means that 
    				addressing modes are very simple as you are either accessing a register, or the op treats the register value as
    				an address (but that decision is based on the op not the parameter). CISC, on the other hand, has more complex 
    				addressing modes where parameters can be treated as registers or addresses to memory along with variations and
    				combinations on top of this. The overall result is CISC has complex sets of addressing possibilities. This can
    				make CISC assembly code complex to read, difficult to understand and prone to errors.
    				
    				- RISC has fewer hardware data types
    				The simpler nature of RISC ops means fewer hardware data types are required by the architecture. This makes
    				assembly code simpler to understand but does mean software data types are even more abstracted from the 
    				hardware representations.
    				    				
    				- RISC requires only instruction pointer to describe state, CISC requires hidden state information
    				RISC ops a single-step and simple so there is (virtually) no temporary caching of state during an operation. This
    				means you could restart an operation without requiring any state restoration. This means that the only thing 
    				required to know the state of a program in a RISC architecture is the instruction pointer and register values.
    				CISC, on the other hand, has lots of state caching during long, complex operations which means that you cannot
    				restart an op without restoring values from the temporary data stores. However, these hardware data stores are 
    				usually not accessible to the developer. This means that even if you know the instruction point at a given moment,
    				you do not know the full state of the processor and by extension, the program.
    			
    			The following are a brief summary of the advantages and disadvantages of RISC vs. CISC from my research of the topic.
    			This topic has been highly debated over the years and there are many articles available through a simple search of
    			"RISC vs. CISC" that give a more in-depth discussion (and justification) of the various stand points. 
    			
    			Advantages of RISC
    				- Architecture and assembler is simpler to learn
    				- Assembler is easier to read
    				- Can have a simpler compiler
    				- Requires less silicon
    				- 	Thus less power and less physical space
    				-	And also less heat, meaning no heat sync (which are not possible in embedded, mobile and tablet applications)
    				
    			Advantages of CISC
    				- Can do complex data handling faster / more efficiently
    				- Requires fewer lines of assembler (improves compile time & efficiency)
    				- Easier for programmer to program more complex data handling (in assembler)
    				- Requires fewer general purpose registers
    				    				
    			Disadvantages of RISC
    				- Has simpler instructions thus requiring more lines of assembler for the same, overall complex operation
    				- Can be less efficient compared to a CISC architecture optimised for your task
    				- More onus on the programmer to figure out how to organise complex data handling
    				- Requires many general purpose registers
    				
    			Disadvantages of CISC
    				- Architecture and assembler is harder to learn
    				- Assembler can be harder to read
    				- Requires a more complex compiler to really make use of the advantages of CISC
    				- Requires more silicon
    				-	 Thus more power and more physical space
    				-	 And more heat is produced, requiring a heat sync which makes the processor bulky
    				
    			Conclusion
    				Here follows my own conclusions from the RISC vs. CISC debate. I have found I agree with the widely popular 
    				opinions:
    				- RISC is simpler, easier to learn and use
    				- RISC is usually lower power
    				- CISC is faster, more powerful
    				- Both are useful for a given specific purpose. You must pick the correct architecture for the job.
    				- RISC is (slightly) more recent and generally liked more so is perhaps better
    				- However, x86 still more common than ARM in PCs so CISC is more accessible
    				- Overall, I would prefer RISC if it weren't for its practical difficulty to develop for.
    				It should be noted that the top-end RISC CPUs and top-end CISC CPUs have both borrowed ideas from each other's
    				designs meaning top-end RISC and CISC CPUs are almost indistinguishable in terms of RISC/CISC. It has become
    				increasingly meaningless to say a CPU is RISC or CISC. The only true remaining CISC architecture is the x86 CPU
    				which Intel appear to be trying to replace as they push into mobile and embedded markets.
   	
    -->
    
    <!--
    
    		ARM vs x86
    			Drawing from RISC vs CISC
    				The RISC vs. CISC debate is largely ARM vs. x86 in the modern, high-power devices such as mobiles, tablets,
    				laptops and, of course, PCs. ARM broadly, wins for low power and space efficiency but x86 wins for high power 
    				and performance.
    			
    			The following is a brief summary of the main points commonly put forward in the x86 vs ARM debate.
    			
    			Advantages of ARM
    				- All the advantages of RISC
    				- In the Raspberry Pi which actually breaks down the high-cost / low-accessibility barrier
    				- Rapidly growing as mobile and tablet become prolific so supporting it is very good and future-proof.
    			
    			Advantages of x86
    				- All the advantages of CISC
    				- It's in almost every PC making it easy to test and develop for
    				- Lots of development resources, examples and tutorials
    				- Virtual machines are faster
    				- Easier to develop for initially
    				- More compilers
    				- You can develop x86 on any platform including Windows. Developing for ARM on Windows is still a little
    				  difficult, primarily due to lack of tools for testing / development which support ARM.
    			
    			Disadvantages of ARM
    				- All the disadvantages of RISC
    				- Hard to access hardware (excl. RPi)
    				- Hard to set up initially
    				- Often must use emulator or you're stuck with Linux on an ARM chip which not all developers like
    				- Development tools often limited to Linux only
    			
    			Disadvantages of x86
    				- All the disadvantages of CISC
    				- More complex to learn advanced operations so you can't really take advantage of the x86 CPU.
    				- Soon to be outdated if you stick to only 32-bit. Intel and AMD are likely to move further away from
    				  x86 (32 or 64-bit) as they attempt to penetrate the mobile, tablet and embedded markets.
    			
    			Conclusion
    				- x86 wins only because it is currently easier to develop for,
    					but if you have the time & effort, ARM would be well worth learning
    			
    
    -->
    
    <!--
    
    		Assemblers Syntaxes
    			General
    				There are a number of different syntaxes used for writing assembly code. Which you use is determined by your
    				compiler. The syntax used by Fling OS is primarily NASM (since Fling OS uses the NASM compiler). 
    				
    				Which assembler you use is determined by you compiler. Which compiler you used is broadly determined by:
    					1. Does the compiler support the architecture you wish to target?
    					2. Do you want/need a compiler capable of cross-platform compiling?
    					3.1. Does the compiler integrate with your toolchain easily?
    					3.2. Do you like the compiler's ASM syntax?
    				(1) and (2) are necessary choices that you must make. (3) are choices which are entirely personal preference.
    				Most assembler compilers have existed for a long time so are stable, well documented and will integrate with 
    				at least one environment very well.
    				    				
    			NASM, MASM, GAS
    				NASM (Netwide Assembler) is an x86 assembler which uses an Intel-like syntax. Alternative compilers/syntaxes 
    				include MASM (Microsoft Macro Assembler), which uses Intel syntax, and another is GAS (GNU Assembler) which 
    				is a cross-platform assembler used by the GNU project. It is worth repeating: NASM and MASM are x86 assemblers 
    				only. If you intend to target ARM, you will not be able to use NASM or MASM.
    			
    			Inline assembler
    				While writing your OS you may need (or just want) to write assembler in with your main code. High-level languages,
    				such as C#, do not permit this (for a variety of reasons). If your language does not support inline assembler, 
    				then working around it is left to you to do. If your language does support inline assembler (such as C) then 
    				which assembler syntax you use is, as before, dependent upon your compiler. You will need to look up the spec
    				for your language implementation (such as MS-C) to find out how to write inline assembler in a way the compiler
    				will understand.
    			
    -->
    <!--
    
    		NASM
    			Notes about NASM & Fling OS
    				As previously mentioned, Fling OS uses the NASM compiler and thus NASM syntax. Assembler samples are given in
    				NASM syntax. If you are using a different syntax, you must be very careful when converting samples. Particular
    				attention should be paid to parameter order, since a failure to switch parameters will entirely break code.
    			
    			A few NASM examples
    				
    				- - - - - - - - - - - - - - - - 32-bit Addition - - - - - - - - - - - - - - - -
    				
    				; This sample adds two numbers and stores the result over one of the first input
    				
    				mov eax, 1 		; Load the first number to add
    				mov ebx, 1		; Load the second number to add
    				add eax, ebx	; Add the two numbers, result stored in eax
    				
    				
    				- - - - - - - - - - - - - - - 32-bit Port Output - - - - - - - - - - - - - - - -
    				
    				; This sample outputs a 32-bit value to an IO port
    				mov eax, 0xDEADBEEF 	; Load the value to send
    				out 0xF0, eax			; Output the value to port 0xF0
    				
    				
    				- - - - - - - - - - - - - - - - Conditional Branching - - - - - - - - - - - - - - - -
    				
    				; This sample loads a number then tests whether it is greater than a specified number.
    				;	If it is greater, it stores 0 in the primary general purpose register
    				;	If it is equal or less, it stores a 1 in the primary general purpose register.
    				; Execution then continues at a common point.
    				
    				; Note: The greater-than test is a signed test
    				
    				mov eax, 1 		; Load the number to test against
    				cmp eax, 10		; Compare the test number (in eax) to the condition value (10)
    				jg GreaterThan	; Jump to the GreaterThan label (defined below) if eax > 10
    				mov eax, 1		; Less than or equal so store 1
    				jmp CommonCode	; Then jump to the common code (skipping then GreaterThan code so we don't overwrite the
    								; 1 that we just stored).
    				GreaterThan:	; Define the GreaterThan label - this defines a point in the program we can jump to.
    				mov eax, 0		; Greater than so store 0
    					; No need to jump to CommonCode - execution will continue to the next line regardless.
    				CommonCode:		; Define the common code label
    				; Execution continues here
    				
    				
    				- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    			
    			Links
    				All links valid as of 2014-09-17
    				- NASM Website : http://www.nasm.us
    				- Netwide Assembler (Wikipedia) : http://en.wikipedia.org/wiki/Netwide_Assembler
    				- NASM Examples (Loyola Marymount University) : http://cs.lmu.edu/~ray/notes/nasmexamples/
    				- Bare Bones with NASM (OSDev) : http://wiki.osdev.org/Bare_Bones_with_NASM
    
    -->
    
    <!-- - - - - - - - - - - - - - - - -  CPUs As Devices  - - - - - - - - - - - - - - - - -->
    
    <!--
    
   			Overview
   				The CPU as a target architecture has been discussed fairly thoroughly above. This section covers
   				the CPU as a device.
   				
   				While your operating system is running, the CPU is the primary device you must manage. Most of the
   				time it acts transparently or as part of your program (e.g. stack and instruction pointer management).
   				Occasionally, however, you will need to give the CPU specific control instructions to tell it what to
   				do or what to set up. Examples of these cases are when the OS first boots, setting up the segmentation 
   				registers and later when you program process switching, handling paged virtual memory.
   				
   				The following sections provide details of:
   					- General features supported by the majority of CPUs which are useful (or necessary) when managing 
   					  the CPU.
   					- x86 specific code samples for some of the general features
   	
   	-->
   	
   	<!--
   	
    		General features
    			ID
    				Most CPUs support some form of ID either in the form of an operation or a register. A CPU ID can take
    				various forms. One of these forms is a revision number, in which case you will need to check the
    				manufacturer website for specific version information. Another form is a bit-field that supplies
    				information about what the CPU supports. You will need to look at the manufacturer website to know
    				what each bit means, but after that you can write generic code that works across different (including 
    				new) CPU versions without adding extra CPU IDs.
    			
    			Halt / Reset
    				All CPUs support a Halt / Reset feature that allows you to programmatically stop or restart the CPU.
    				If you stop the CPU, the only events which will cause the CPU to resume are:
    					- A non-maskable interrupt occurs
    					- An unmasked maskable-interrupt occurs
    					- Power to the CPU is cycled
    				CPU halt is useful for implementing CPU sleep functionality. You can stop the CPU from executing until
    				a timer interrupt occurs thus allowing you to wait for a short period of time without using a (busy-)loop. 
    				
    				CPU reset is implemented in a number of ways. For example, the PS2 keyboard reset line has been a 
    				long-standing way to hard reset the CPU of a PC. Reset is also achieved through reset ops or the ACPI 
    				features.
    			
    			Speed
    				Most modern CPUs support a way of determining the speed of the CPU. This speed can be in clock-frequency,
    				clock-interval or potentially some other measurement. The speed of the CPU is useful in time-based functions
    				such as CPU time allocation and for outputting to the user, so they can show it off to their mates ;)
    			
    			Multiple CPUs / Multicore
    				For CPUs which have multiple cores or which are designed to work in parallel with other CPUs, functions for
    				synchronising cores, transferring data consistently and other necessary cross-core / cross-CPU functions 
    				will be provided.
    
    -->
    
    <!--
    
    		x86
    			ID
    			
    			Halt
    			
    			Reset
    			
    
    -->
    
    <!-- - - - - - - - - - - - - - - - -  Tutorials - - - - - - - - - - - - - - - - -->
    
    
    <!-- - - - - - - - - - - - - - - - -  Further Reading  - - - - - - - - - - - - - - - - -->
    
    
    <!-- - - - - - - - - - - - - - - - -  References  - - - - - - - - - - - - - - - - -->
    
    
    <section address="Introduction">
      <title>Introduction</title>
      <sections>
          <section address="Introduction_ScopeOfThisArticle">
              <title>Scope of this article</title>
              <content>
                  <para>
                  	This article covers two broad topics. The first is CPU Architecture. This provides an explanation of 
					what is meant by CPU Architecture followed by a discussion of general information. This is further
					followed by discussion of the main two CPU architectures developers are likely to be working with,
					namely, ARM and x86. A limited discussion of assembler programming is also included. 
				  </para>
				  <para>
					The second topic covered by this article is CPUs As Devices. This provides a different perspective
					on a CPU, looking at it from the OS developer's point of view once the kernel is running. It looks
					at the CPU as a device which must be managed and can be used to perform specific processor functions.
                  </para>
              </content>
          </section>
          <section address="Introduction_HowThisArticleIsStructured">
              <title>How this article is structured</title>
              <content>
                  <para>
					This article is structured into the two sections described. These are further split into sub-sections
					which follow the general pattern presented here (where each item listed is only included in a given 
					sub-section if it is appropriate):
                  </para>
				  <list class="ordered">
					<listItem><para>Overview (of what the sub-section will discuss)</para></listItem>
					<listItem><para>General discussion</para></listItem>
					<listItem><para>Specific examples</para></listItem>
					<listItem><para>Discussion of selected specific examples</para></listItem>
					<listItem><para>One example vs. another</para></listItem>
					<listItem><para>Code examples</para></listItem>
					<listItem><para>Conclusion</para></listItem>
					<listItem><para>Links to useful resources</para></listItem>
				  </list>
              </content>
          </section>
      </sections>
    </section>
       
    <section address="CPUArchitecture">
      <title>CPU Architecture</title>
      <sections>
          <section address="CPUArchitecture_Overview">
              <title>Overview</title>
              <sections>
		          <section address="CPUArchitecture_Overview_ClarifyingWhatACPUIs">
		              <title>Clarifying what a CPU is</title>
		              <sections>
				          <section address="CPUArchitecture_Overview_ClarifyingWhatACPUIs_Definition">
				              <title>Definition</title>
				              <content>
				                  <para>
				                  	The Central Processing Unit (CPU or just "processor" for short), is the primary piece of hardware 
				    				which executes program instructions. A CPU performs the fundamental arithmetic, logic and input/
				    				output operations required to manipulate data in a useful way.
				                  </para>
				              </content>
				          </section>
				          <section address="CPUArchitecture_Overview_ClarifyingWhatACPUIs_Explanation">
				              <title>Explanation</title>
				              <content>
				                  <para>
				                  	The CPU acts as the "brains" of a computer system (be it a PC, tablet or mobile). Everything you
				    				want to do, has to start somewhere in the CPU. In the simplest case, your PC would have only one
				    				CPU, with one logical processing unit on that CPU. However, modern CPUs consist of multiple processing
				    				units and modern PCs can contain multiple CPUs. It is probably helpful to think of a processing
				    				unit as a CPU in its own right. While this is not strictly correct, it is sufficient to realise
				    				that each processing units acts, in the simple cases, mostly independently of the other units. 
				                  </para>
				                  <para>
				                  	A processing unit is a piece of hardware which (ignoring how it does the following) loads a set of
				    				program instructions from memory and then executes each instruction sequentially, until either
				    				reaching the end of those instructions or faulting. The instructions a CPU executes can be broken
				    				down into 5 main categories:
				                  </para>
				                  <list class="bullet">
				                  	<listItem>
				                  	  <para>
				                  		Data transfer : Ops for transferring data to/from memory or other devices.
				                  	  </para>
				                  	</listItem>
				                  	<listItem>
				                  	  <para>
			    						Arithmetic : Add, subtract, multiply, divide and various other operations involving one or 
			    									 more numbers.
				                  	  </para>
				                  	</listItem>
				                  	<listItem>
				                  	  <para>
			    						Logical : Bit-wise logical AND, OR, XOR, NOT and various other operations involving one
			    								  or more binary numbers.
				                  	  </para>
				                  	</listItem>
				                  	<listItem>
				                  	  <para>
			    						Control flow : Branch, jump, loop and various other ops which control which instructions get
			    									   executed next. 
				                  	  </para>
				                  	</listItem>
				                  	<listItem>
				                  	  <para>
			    						Other : A category which encompasses a wide range of ops from those which control
			    								Interrupts to processor specific ops to binary shift/rotate ops.
				                  	  </para>
				                  	</listItem>
				                  </list>
				                  <para>
				    				It is key to understand that everything a computer does can be made up of a combination of these 
				    				types of operation. For instance, if you wish to multiply two numbers x and y together, you must
				    				perform:
				    			  </para>
				    			  <list class="ordered">
				    					<listItem><para>A data transfer op to load x from memory</para></listItem>
				    					<listItem><para>A data transfer op to load y from memory</para></listItem>
				    					<listItem><para>An arithmetic op to multiply x by y</para></listItem>
				    					<listItem><para>A data transfer op to store the result</para></listItem>
				    			  </list>
				    			  <para>
				    				Or, if you wish to load an element from an array you must perform:
				    			  </para>
				    			  <list class="ordered">
				    					<listItem><para>A data transfer op to load the address of the start of the array</para></listItem>
				    					<listItem><para>A data transfer op to load the index of the element to get</para></listItem>
				    					<listItem><para>A data transfer op to load the size, in bytes, of each element in the array</para></listItem>
				    					<listItem><para>
				    						An arithmetic op to multiply the index by the size to get the offset of the element from the start of
				    					    the array
				    					</para></listItem>
				    					<listItem><para>An arithmetic op to add the offset to the address of the array</para></listItem>
				    					<listItem><para>A data transfer op to load the value at the newly calculated address</para></listItem>
				    					<listItem><para>A data transfer op to store the loaded value</para></listItem>
				    			  </list>
				    			  <para>
				    				Of course, depending on your architecture, the above steps may or may not be optimised to fewer steps. 
				    				None the less, the same basic operations are being performed. This will be further discussed in
				    				later topics covering CPU Architectures.
				    			  </para>
				    			  <para>
				    				The key thing to take away from this explanation, is that a CPU executes instructions which control what
				    				the computer does. It is we, humans, who assign meaning to the data passing through the CPU and how that
				    				data is manipulated.
				    			  </para>
				              </content>
				          </section>
				          <section address="CPUArchitecture_Overview_ClarifyingWhatACPUIs_AsATarget">
				              <title>As a target</title>
				              <content>
				                  <para>
				                  	The first perspective of a CPU that a developer must understand when developing an OS is that the CPU is
				    				a target. You pick a particular CPU (or a particular group of CPUs) which you want your OS to run on. 
				    				This is what you are targeting. Each CPU (or group of CPUs) will have its own set of features, its own
				    				particular set of instructions and its own requirements from the OS. There is no one-size-fits-all way 
				    				of programming the low-level parts of an OS. Once you settle on which CPU(s) to target, you must stick
				    				to that choice until you at least get your basic kernel working. After that, you can consider porting
				    				your code to other targets.
				                  </para>
				              </content>
				          </section>
				          <section address="CPUArchitecture_Overview_ClarifyingWhatACPUIs_AsADevice">
				              <title>As a device</title>
				              <content>
				                  <para>
				                  	The second perspective of a CPU that a developer will need to understand when developing an OS is that the
				    				CPU is a device. It is a device as much as your mouse, keyboard and screen are devices. It requires 
				    				managing while your OS is running. This management ranges from the very simple (like telling it where to 
				    				get the next instruction from) to the very complex (such as managing multiple processing units). 
				    			  </para>
				    			  <para>
				    				While you could think of the CPU device as a target device - a device which your OS will support management
				    				of - it would be a little unwise to do so. Thinking of it as a target would lead to the idea that methods
				    				of management applied to one CPU, cannot be applied to another. This is not the case. If you were to write
				    				a CPU manager to manage multiple processing units, you could probably use the same code on another CPU too.
				    				The difference is that your compiler would need to target a different CPU. The code remains logically the 
				    				same (i.e. the CPU as a device, remains logically the same) but the actual outputted instructions change to
				    				the ones required for the specific CPU you targeted. 
				    			  </para>
				    			  <para>
				    				It is important to realise that the CPU as a target affects what the compiler produces. The CPU as a device
				    				affects what you program. If you are programming in assembler, then clearly the target CPU will also affect
				    				what you program but the logic of what you program can (usually) remain the same. 
				    			  </para>
				    			  <para>
				    				For more information about the CPU as a device, see "CPUs As Devices" sections further down in this article.
				                  </para>
				              </content>
				          </section>
				      </sections>
		          </section>
		          <section address="CPUArchitecture_Overview_WhatIsMeantByArchitecture">
		              <title>What is meant by "architecture"?</title>
		              <sections>
				          <section address="CPUArchitecture_Overview_WhatIsMeantByArchitecture_Definition">
				              <title>Definition</title>
				              <content>
				              	<para>
				    				A CPU architecture is a CPU design (but this statement is hardly any help). A CPU architecture lays out
				    				designs for every aspect of the CPU. What this encompasses, of course, varies from CPU to CPU, which makes
				    				a definition rather difficult. However, we can say the following. A CPU architecture usually encompasses the 
				    				following designs / specifications:
    							</para>
    							<list class="bullet">
			    					<listItem><para>Instruction Set</para></listItem>
			    					<listItem><para>Hardware features (e.g. registers, virtual memory)</para></listItem>
			    					<listItem><para>Software conventions (e.g. register uses)</para></listItem>
				                 </list>
				              </content>
				          </section>
				          <section address="CPUArchitecture_Overview_WhatIsMeantByArchitecture_Explanation">
				              <title>Explanation</title>
				              <content>
				              	<para>
				                  Looking at these areas in more detail:
				                </para>
				                <list class="bullet">
			    					<listItem>
			    					  <para>Instruction set -
										This is the set of assembler ops. This has been mentioned and detailed before in
										"Clarifying what a CPU is - Explanation". The CPU instructions and the instruction
										set are (to all intents and purposes) the same thing. The instruction set lays out
										precisely what each operation does, any side effects and any required or optional
										parameters (often in the form of registers) to the op. The instruction set also
										defines the identifiers for the registers available in the CPU.
			    				 	  </para>
			    				 	</listItem>
			    					<listItem>
			    					  <para>Hardware features -
										The hardware features define what the CPU is capable of doing. This ranges from
										what registers are available (and for what purposes) through to how IO ports are 
										accessed through to how the Memory Management Unit is controlled. The basic 
										hardware features of CPUs are fairly similar across all CPUs these days meaning
										you need only really learn the instruction set to find out how to begin programming
										the basics. More complex features obviously begin to vary a lot as that is what sets 
										different CPUs apart.
			    					  </para>
			    					</listItem>
			    					<listItem>
			    					  <para>Software features -
										The software features define how the CPU designers expect it to be used (and may
										also impose some practical restrictions that the compiler or hardware enforce.)
										For example, software features might include specifying which registers
										should be used for return values from a function call. This isn't necessarily 
										enforced by anything so in theory  you could probably work against the software 
										design features but you'd be foolish to do so. The designers probably knew what
										they were talking about! What is defined in the software features varies wildly
										and whether you have to stick to them is also variable. You will always have to
										read the specs for your specific target architecture to find out what they say 
										for this section.
			    					  </para>
			    					</listItem>
    							</list>
    							<para>
									It is probably apparent that each of these areas is closely linked to the other. For example, the specific 
									hardware registers each have names which are then used in the instruction set. Register uses are sometimes 
									strictly defined which also sets out which instructions can be used thus further defining the instruction set. 
									Thoroughly understanding your target CPU's architecture will put you in a good stead when it comes to 
									programming the first bits of code related to booting your OS and initialising the CPU.
    							</para>
				              </content>
				          </section>
				          <section address="CPUArchitecture_Overview_WhatIsMeantByArchitecture_AlternativeUses">
				              <title>Alternative Uses</title>
				              <content>
				                  <para>
				    				It should also be noted that the term "CPU architecture" may be used in other contexts for example hardware
				    				engineers may use it to refer to the precise design and layout of one particular CPU and ignore the software
				    				features entirely.
				                  </para>
				              </content>
				          </section>
				      </sections>
		          </section>
		          <section address="CPUArchitecture_Overview_WhatAreSomeGeneralDifferencesBetweenArchitectures">
		              <title>What are some general differences between architectures?</title>
		              <sections>
					      <section address="CPUArchitecture_Overview_WhatAreSomeGeneralDifferencesBetweenArchitectures_LittleVsBigEndian">
					          <title>Little vs. big endian</title>
					          <content>
					              <para>
					              	A fundamental difference between architectures is whether they are little or big endian. This is something which
				    				often trips people up when converting examples between architectures. Little and big endian refer to the order
				    				in which the most to least significant bytes are stored in memory. In short, little endian means the least 
				    				significant byte is stored at the lower address. Big endian means the most significant byte is stored at the 
				    				lower address. For a fuller explanation, please see the following articles:
					              </para>
					              <list class="bullet">
				    				 <listItem>
				    				 	<para>
							         		<externalLink>
											    <linkText>http://en.wikipedia.org/wiki/Endianness</linkText>
											    <linkAlternateText>http://en.wikipedia.org/wiki/Endianness</linkAlternateText>
											    <linkUri>http://en.wikipedia.org/wiki/Endianness</linkUri>
											</externalLink>
				    				 	</para>
				    				 </listItem>
				    				 <listItem>
				    				 	<para>
							         		<externalLink>
											    <linkText>http://www.cs.umd.edu/class/sum2003/cmsc311/Notes/Data/endian.html</linkText>
											    <linkAlternateText>http://www.cs.umd.edu/class/sum2003/cmsc311/Notes/Data/endian.html</linkAlternateText>
											    <linkUri>http://www.cs.umd.edu/class/sum2003/cmsc311/Notes/Data/endian.html</linkUri>
											</externalLink>
				    				 	</para>
				    				 </listItem>
				    			  </list>
					              <para>
				    				  (All links were valid as of 10-09-2014)
					              </para>
					          </content>
					      </section>
					      <section address="CPUArchitecture_Overview_WhatAreSomeGeneralDifferencesBetweenArchitectures_RegisterSizes">
					          <title>Register sizes</title>
					          <content>
					          	<para>
					              	Another common difference between architectures is register sizes. The maximum register size will affect 
				    				(and possibly limit) that largest number of bytes you can operate on in one operation. You can expect that 
				    				in a 32-bit architecture, the largest CPU register (not FPU register) will be 32-bits wide. Similarly, in a 
				    				64-bit architecture the largest CPU register is likely to be 64-bits wide. (This may not always hold true but 
				    				it is a reasonable rule of thumb.) Most general purpose registers are also subdivided into smaller registers 
				    				that are 16 and 8 bits wide. For example, on x86 the primary (A) general purpose register can be accessed as 
				    				follows:
				    			</para>
				    			<list class="bullet">
			    					<listItem><para>EAX = 32-bits wide</para></listItem>
			    					<listItem><para>AX = 16-bits wide, Lower 16-bits of EAX</para></listItem>
			    					<listItem><para>AL =  8-bits wide, Lower  8-bits of  AX</para></listItem>
			    					<listItem><para>AH =  8-bits wide, Higher 8-bits of  AX</para></listItem>
    							</list>
					          </content>
					      </section>
					      <section address="CPUArchitecture_Overview_WhatAreSomeGeneralDifferencesBetweenArchitectures_RegisterUses">
					          <title>Register uses</title>
					          <content>
					          	<para>
					              	What uses registers are assigned to varies depending on what features a CPU is attempting to support. All CPUs
				    				(with perhaps the exception of some specialist units) have general purpose registers that are used for any 
				    				purpose the programmer desires. CPUs then have various special purpose registers. The following are possible
				    				examples of some:
    							</para>
    							<list class="bullet">
			    					<listItem>
			    						<para>
			    							FPU registers - used by the floating point units (FPUs) for floating point calculations
			    						</para>
			    					</listItem>
			    					<listItem>
			    						<para>
			    							Segment registers - used by the CPU for managing segmented memory
			    						</para>
			    					</listItem>
			    					<listItem>
			    						<para>
				    						Descriptor registers - used by the CPU to store / load the address of descriptors tables used to provide
				    											   data / guidance (not really instructions) to the CPU on how to process things. 
				    											   For example, these contain the Interrupts Descriptor Table which provides interrupt
				    											   function addresses.
			    						</para>
			    					</listItem>
			    					<listItem>
			    						<para>
			    							Processor registers - used by the CPU for managing the current program execution. For example, the stack,
			    												  base and current instruction pointers.
			    						</para>
			    					</listItem>
			    					<listItem>
			    						<para>
			    							Many more...but you will come across these as you explore the architecture you pick.
			    						</para>
			    					</listItem>
    							</list>
					          </content>
					      </section>
					      <section address="CPUArchitecture_Overview_WhatAreSomeGeneralDifferencesBetweenArchitectures_HardwareAccess">
					          <title>Hardware access e.g. IO Ports</title>
					          <content>
					          	<para>
					              	Another key difference between architectures is how you access other parts of the hardware, be they part of the
				    				motherboard or attached via sockets. The FPU and MMU are now often part of the CPU hardware and are accessed
				    				simply by using special registers and special CPU instructions. However, there are a number of standards for 
				    				communication with attached devices, such as PCI(e) (on top of which also sits USB) and SATA (for hard-drives). 
				    				However, both of these standards, along with many others work somewhat independently of how data is actually 
				    				transferred to and from the CPU and the data buses. In general, this transfer mechanism is called an IO Port. 
				    				How IO Ports operate from the CPU's perspective depends upon the CPU and motherboard architecture. As an example, 
				    				the x86 architecture offers the ability to map IO ports to particular memory addresses. You then use the special 
				    				in/out operations to respectively write / read the ports. (Note: x86 also has memory mapped registers where data 
				    				buses are mapped directly to address ranges but this is a further form of IO port system.)
    							</para>
					          </content>
					      </section>
					      <section address="CPUArchitecture_Overview_WhatAreSomeGeneralDifferencesBetweenArchitectures_MemoryManagement">
					          <title>Memory management</title>
					          <content>
					          	<para>
									As has been mentioned briefly previously, memory management also varies. Older CPU architectures used a 
				    				segmented virtual memory system but modern CPUs most often use a paged memory system. The advantages and
				    				disadvantages of the two are beyond the scope of this article. However, it should be noted that which
				    				option is supported by your target CPU (or possibly both options e.g. x86) can have a big impact on your 
				    				OS design.
			    				</para>
					          </content>
					      </section>
					      <section address="CPUArchitecture_Overview_WhatAreSomeGeneralDifferencesBetweenArchitectures_InstructionSets">
					          <title>Instruction sets</title>
					          <content>
					          	<para>
						            As has been discussed in detail previously, the instruction set of a CPU architecture is very particular to
				    				precisely what the CPU supports. Hence, it varies from CPU to CPU. However, as you will see later in this 
				    				article, the same basic set of instructions can be used across a wide range of CPUs. This will be discussed 
				    				in more depth later.
			    				</para>
					          </content>
					      </section>
					  </sections>
		          </section>
		          <section address="CPUArchitecture_Overview_WhatAreTheMainEffectsOfTheseDifferences">
		              <title>What are the main effects of these differences?</title>
		              <content>
		              	<para>
		                  	There are several effects of these differences which are covered briefly below, though an in depth discussion
		    				of the good / bad aspects of every difference would take more words than it is worth. You need only note
		    				the general points to be able to make a reasonably informed decision about which architecture you choose.
    					</para>
    				  </content>
    				  <sections>
				          <section address="CPUArchitecture_Overview_WhatAreTheMainEffectsOfTheseDifferences_EaseOfLearning">
				              <title>Ease of learning / Ease of use</title>
				              <content>
				              	<para>
				                  	The more specialist the CPU architecture you target, the harder it will be to learn. This is for several, broad
				    				reasons:
				    			</para>
				    			<list class="ordered">
				    				<listItem><para>
				    					The instruction set is (probably) very specific / specialist which will reduce the likelihood of the being
				    					   resources freely available online
				    				</para></listItem>
				    				<listItem><para>
				    					Specialist hardware means specialist knowledge and probably a load of standards nobody has ever heard of. 
				    					   This further reduces the likelihood of there being a good pool of resources available to you.
				    				</para></listItem>
				    				<listItem><para>
				    					Specialist means just that, specialist. It is likely that you will not be able to port code or concepts 
				    					   from other architectures to help you, so you will be very much alone.
				    				</para></listItem>
				    			</list>
				    			<para>
				    				On the plus side, specialist CPUs are less and less common and for the average (haha!) OS developer, you need
				    				only target popular architectures such as x86 and ARM. (Note: x86 and ARM architectures are discussed in more
				    				detail later.)
				    			</para>
				              </content>
				          </section>
				          <section address="CPUArchitecture_Overview_WhatAreTheMainEffectsOfTheseDifferences_PowerConsumption">
				              <title>Power Consumption</title>
				              <content>
				             	<para>
					              	The larger the instruction set, the more hardware will be required to support the instructions. In general this
				    				means more physical silicon which in turn means a higher power consumption. This is broadly the history of the
				    				battle between the ARM and Intel architectures but this will be discussed in more detail later. Either way,
				    				the architecture you choose to support will have a big impact on the CPU power consumption. If you are 
				    				programming for an embedded environment (such as watches or phones), this is a big deciding factor.
			    				</para>
				              </content>
				          </section>
				          <section address="CPUArchitecture_Overview_WhatAreTheMainEffectsOfTheseDifferences_Speed">
				              <title>Speed</title>
				              <content>
				                  <para>
				                  	Larger instruction sets, more specialist ops, more registers, more sophisticated memory management, etc. All of 
				    				these things will, if properly and fully utilised, make your OS run much faster. However, you will certainly
				    				spend a lot longer developing your OS, as you will have to spend time optimising it here, there and everywhere
				    				to gain the full benefit of the aforementioned features. So what you gain in runtime speed, you pay for massively
				    				in development speed.
				                  </para>
				              </content>
				          </section>
				          <section address="CPUArchitecture_Overview_WhatAreTheMainEffectsOfTheseDifferences_CompilerComplexity">
				              <title>Compiler Complexity</title>
				              <content>
				                  <para>
				                  	You probably don't care about this, unless you are planning on writing your own compiler (a task which is 
				    				considered as challenging as writing an OS!) A large instruction set or specialist ops or few general purpose
				    				registers will make writing a good compiler more challenging. This is because your compiler will have to pay
				    				much closer attention to what is happening to the data and how/when it can use specialist ops or reuse registers.
				    				A discussion of compiler design is not included in the Fling OS articles but given the existence of GCC, MSBuild
				    				and numerous other open-source compilers for just about every language, you should be able to find one that 
				    				works for you somewhere.
				                  </para>
				              </content>
				          </section>
				      </sections>
		          </section>
		          <section address="CPUArchitecture_Overview_SpecificArchitectureExamples">
		              <title>Specific architecture examples</title>
		              <content>
		              	<para>
		    				A few examples of widely available / well known architectures:
		    			</para>
		    			<list class="bullet">
		    			 	<listItem><para>x86 (inc. 32 and 64 bit versions)</para></listItem>
		    			 	<listItem><para>ARM (inc. 32 and 64 bit variants)</para></listItem>
		    			 	<listItem><para>MIPS (3)</para></listItem>
		    			 	<listItem><para>PowerPC</para></listItem>
		    			 </list>
		    			 <para>
		    			 	A fuller list (ordered by name) can be found at: 
		    			 	<externalLink>
							    <linkText>http://en.wikipedia.org/wiki/Comparison_of_instruction_set_architectures</linkText>
							    <linkAlternateText>http://en.wikipedia.org/wiki/Comparison_of_instruction_set_architectures</linkAlternateText>
							    <linkUri>http://en.wikipedia.org/wiki/Comparison_of_instruction_set_architectures</linkUri>
							</externalLink>
							
		    			 	(Link valid as of 10-09-2014.)
		    			 </para>
		              </content>
		          </section>
		          <section address="CPUArchitecture_Overview_FinalNoteBeforeWeMoveOn">
		              <title>Final note before we move on</title>
		              <content>
		                  <para>
		    				I should note at this point that I have talked very much as though you have a choice over the CPU architecture
		    				you choose to target. This is possibly helpful and misleading at the same time. In most cases you will be forced
		    				to target the CPU architecture you have available to you. That is likely to be either your development machine's
		    				architecture (most likely x86) or the architecture of a development device such as the Raspberry Pi (ARM).
		    				If you plan on creating your own custom set of hardware (which may be possible with Google's initiatives in
		    				plug-and-play designs) then you are in the fortunate position of truly deciding for yourself!
		                  </para>
		              </content>
		          </section>
		      </sections>
          </section>
          
          <section address="CPUArchitecture_IntelAMDx86Architecture">
          	<title>Intel / AMD x86 Architecture</title>
          	<sections>
          		<section address="CPUArchitecture_IntelAMDx86Architecture_BriefSummary">
          			<title>Brief summary of key details</title>
          			<sections>
          				<section address="CPUArchitecture_IntelAMDx86Architecture_BriefSummary_Origin">
          					<title>Origin - Intel</title>
          					<content>
          						<para>
	          						The following is a good article that covers the history of x86 better than my brief summary below:
	          						<externalLink>
									    <linkText>A brief history of the x86 microprocessor</linkText>
									    <linkAlternateText>http://www.computerworld.com/article/2535019/computer-hardware/timeline--a-brief-history-of-the-x86-microprocessor.html</linkAlternateText>
									    <linkUri>http://www.computerworld.com/article/2535019/computer-hardware/timeline--a-brief-history-of-the-x86-microprocessor.html</linkUri>
									</externalLink>.
								</para>
								<para>
					    			The x86 architecture originates from the first Intel 8086 CPU (which itself was a 16-bit redesign of the 8008 
					    			and 8080 CPUs). The 8086 was a 16-bit CPU but later designs extended the x86 architecture to 32-bit and then
					    			64-bits. AMD also adopted the architecture for their CPUs and did the work to extend the instruction set to 
					    			64-bits (which Intel later re-adopted). Thus has led to the instruction set being known as the Intel / AMD x86 
					    			Instruction Set since the (non-processor-model-specific) set of instructions has been co-specified by the two 
					    			companies. Compilers often refer to the x86 32-bit architecture as IA32 and x86 64-bit as AMD64 as these are
					    			the original / official names for the two architectures.
					    		</para>
          					</content>
          				</section>
          				<section address="CPUArchitecture_IntelAMDx86Architecture_BriefSummary_History">
          					<title>A lot of history = a lot of baggage (see CISC and Segmented memory)</title>
          					<content>
          						<para>
					    			The x86 processor is steeped in history and, because it has always been backwards compatible, the
					    			architecture contains some outdated features that are no longer used. Examples include segmented virtual memory
					    			which, in the majority of new OS'es, has been replaced with paged virtual memory. You should also note that 
					    			x86 64-bit processors are fully compatible with 32-bit assembly code. So if you build an x86 32-bit OS, it will
					    			also run on x86 64-bit processors. This is useful when considering testing on modern PCs which now mostly come 
					    			with 64-bit processors.
				    			</para>
          					</content>
          				</section>
          				<section address="CPUArchitecture_IntelAMDx86Architecture_BriefSummary_StandardForPCs">
          					<title>Standard for PCs</title>
          					<content>
          						<para>
	          						x86 processors have long been the standard processor architecture PCs since Windows is built for the x86. Linux
					    			now also has many builds for x86. Consequently, if you build an OS targeting x86 (32-bit) you will be able to
					    			test it on almost any PC you find. (Though you may have issues with BIOS/UEFI/alternatives that prevent your OS
					    			booting, but that is different issue.)
          						</para>
          					</content>
          				</section>
          				<section address="CPUArchitecture_IntelAMDx86Architecture_BriefSummary_StandardForMacs">
          					<title>Now standard for Macs</title>
          					<content>
          						<para>
					    			The architecture has become so solidly associated with PCs that Apple switched Macs from PowerPC to x86 to 
					    			increase compatibility. (Note: Apple fan-boys may never admit that Apple gave in to the PC on processor architecture, 
					    			but that's mostly a matter of opinion and not one which I care about much...)
	    						</para>
          					</content>
          				</section>
          				<section address="CPUArchitecture_IntelAMDx86Architecture_BriefSummary_CISC">
          					<title>Complex instruction set (see CISC)</title>
          					<content>
          						<para>
					    			x86 follows a CISC (Complex Instruction Set Computing) design. For more information on what this means and its
					    			impact, please see later in this article.
	    						</para>
          					</content>
          				</section>
          				<section address="CPUArchitecture_IntelAMDx86Architecture_BriefSummary_FewGeneralPurposeRegisters">
          					<title>Few general purpose registers</title>
          					<content>
          						<para>
					    			The x86 architecture has only 4 general purpose registers (which themselves have specialist purposes depending on
					    			the specific op). It also has a fair few specialist registers. Many vs. few general purpose registers is discussed 
					    			more later. The x86 general purpose registers are called A, B, C and D. They have been mentioned previously in 
					    			"General Differences Between Architectures : Register Sizes". The names of the different sized versions are listed 
					    			below:
	    						</para>
	    						<pre>
	    					Lo 8-bits		Hi 8-bits		Lo 16-bits		(Lo) 32-bits		64-bits (if x64)
	    						AL				AH				AX				EAX					 RAX
	    						BL				BH				BX				EBX					 RBX
	    						CL				CH				CX				ECX					 RCX
	    						DL				DH				DX				EDX					 RDX
	    						</pre>
	    						<para>
					    			These registers can be used for anything broadly you like except when you use specific ops (for example the "loop"
					    			op). 		
	    						</para>
          					</content>
          				</section>
          				<section address="CPUArchitecture_IntelAMDx86Architecture_BriefSummary_LittleEndian">
          					<title>Little endian</title>
          					<content>
          						<para>
	    							Please note that the x86 architecture is always little endian.
	    						</para>
          					</content>
          				</section>
          				<section address="CPUArchitecture_IntelAMDx86Architecture_BriefSummary_HighPower">
          					<title>Traditionally, high power consumption</title>
          					<content>
          						<para>
					    			The x86 architecture, as created by Intel and AMD, has traditionally had high power consumption which is largely
					    			the reason it has dominated the PC market but not penetrated the mobile or tablet markets. The reasons for its 
					    			higher power consumption are discussed later in RISC vs CISC. However, since the x86 architecture is high power:
	    						</para>
	    						<list class="ordered">
	    							<listItem><para>
	    								You (in my opinion) needn't trouble yourself too much with writing super-optimised code the first couple
	    				   				of times you try. You should focus more on readability and maintainability. The power of the CPU and the 
	    				   				compiler will probably do a better job than any optimisations you try and add. 
	    				   			</para></listItem>
	    				   			<listItem><para>
				    				   You (in my opinion) needn't spend hours supporting power optimisations for devices (such as sleep mode in
				    				   USB). You are likely to spend a lot of time programming for no real benefit (even if you are targeting
				    				   laptops - you are more likely to benefit from writing more useful drivers than power optimised ones!)
	    							</para></listItem>
	    						</list>
          					</content>
          				</section>
          				<section address="CPUArchitecture_IntelAMDx86Architecture_BriefSummary_32BitIsEasier">
          					<title>Easiest to learn 32-bit</title>
          					<content>
          						<para>
					    			It is advisable to learn the 32-bit x86 instruction set and use it extensively before you start on the 64-bit 
					    			version. The 32-bit version is complex enough with enough specialist ops let alone the 64-bit version. The 64-bit
					    			version adds more specialist ops, extended registers and, if you adhere to the design advise closely, an annoyingly
					    			complicated calling convention (by comparison to the 32-bit version).
	    						</para>
          					</content>
          				</section>
          				<section address="CPUArchitecture_IntelAMDx86Architecture_BriefSummary_HighResourceCount">
          					<title>High number of resources and examples for x86</title>
          					<content>
          						<para>
					    			The x86 architecture has a significantly large number of resources (especially by comparison to ARM). As an OS
					    			developer this will be vital. Additionally, Fling OS currently only targets x86 so all resources and examples are 
					    			written from an x86 perspective. 
	    						</para>
          					</content>
          				</section>
          				<section address="CPUArchitecture_IntelAMDx86Architecture_BriefSummary_EasyToTest">
          					<title>Easy to test</title>
          					<content>
          						<para>
					    			Since the x86 architecture is so prolific in PCs, testing code written for it is very easy. Real hardware is
					    			widely available and USB boot sticks are easy to create and update. Furthermore, virtual machines work on the same 
					    			architecture as the host PC and, since most PCs have x86 in them, you can test x86 code on most PCs. Also, x86 
					    			emulators for Windows, Linux and Mac are widely available. Both virtual machines and emulators are freely available 
					    			such as VMWare Player, Virtual Box and Qemu.
	    						</para>
          					</content>
          				</section>
          				<section address="CPUArchitecture_IntelAMDx86Architecture_BriefSummary_AdditionalInfoContributions">
          					<title>If you have any additional useful information (or just header titles)</title>
          					<content>
          						<para>
          							Please submit them for addition.
          						</para>
	    					</content>
          				</section>
          				<section address="CPUArchitecture_IntelAMDx86Architecture_BriefSummary_CISCArchitecture">
          					<title>CISC architecture</title>
          					<content>
          						<para>
					    			As has been mentioned several times previously, x86 is synonymous with CISC architecture design. More information
					    			about the theory behind CISC and a comparison to RISC is provided later in this article.
	    						</para>
          					</content>
          				</section>          			
          			</sections>
          		</section>
          		<section address="CPUArchitecture_IntelAMDx86Architecture_SpecificationSources">
          			<title>Specification sources</title>
          			<content>
          				<para>
	    					Links valid as of 2014-09-16
	    				</para>
	    				<list class="bullet">
	    					<listItem><para>
	    						<externalLink>
								    <linkText>Intel x86 specs</linkText>
								    <linkAlternateText>http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html</linkAlternateText>
								    <linkUri>http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html</linkUri>
								</externalLink>	    						
	    					</para></listItem>
	    					<listItem><para>
	    						<externalLink>
								    <linkText>x86 Instruction set listings</linkText>
								    <linkAlternateText>http://en.wikipedia.org/wiki/X86_instruction_listings#Added_with_80386</linkAlternateText>
								    <linkUri>http://en.wikipedia.org/wiki/X86_instruction_listings#Added_with_80386</linkUri>
								</externalLink>
	    					</para></listItem>
	    					<listItem><para>
	    						<externalLink>
								    <linkText>x86 Instruction set reference site</linkText>
								    <linkAlternateText>http://en.wikibooks.org/wiki/X86_Assembly</linkAlternateText>
								    <linkUri>http://en.wikibooks.org/wiki/X86_Assembly</linkUri>
								</externalLink>
	    					</para></listItem>
	    				</list>
          			</content>
          		</section>
          		<section address="CPUArchitecture_IntelAMDx86Architecture_32Or64Bit">
          			<title>32-bit or 64-bit?</title>
          			<content>
          				<para>
			    		 	When deciding which version of the architecture to target, there are a few aspects to consider (most of which have 
			    		 	been mentioned at least briefly before):
			    		</para>
			    		<list class="bullet">
			    			<listItem><para>32-bit : Easiest to learn</para></listItem>
			    		 	<listItem><para>32-bit : Maximum compatibility</para></listItem>
			    		 	<listItem><para>32-bit : Has simpler calling convention (if you follow design / spec advice)</para></listItem>
			    		 	<listItem><para>64-bit : Once you are very advanced or if you have special purposes</para></listItem>
			    		 	<listItem><para>64-bit : Adds a lot of complexity so only use it if you will really reap the benefits</para></listItem>
	    		 		</list>
          			</content>
          		</section>
          		<section address="CPUArchitecture_IntelAMDx86Architecture_DevTools">
          			<title>Links to x86 development tools</title>
          			<content>
          				<para>
	    					Links valid as of 2014-09-16
	    				</para>
	    				<list class="bullet">
	    					<listItem><para>
	    						<externalLink>
								    <linkText>NASM compiler</linkText>
								    <linkAlternateText>http://www.nasm.us/</linkAlternateText>
								    <linkUri>http://www.nasm.us/</linkUri>
								</externalLink>
	    					</para></listItem>
	    					<listItem>
	    						<para>
	    							Virtual machines (if running on x86 hardware):
	    						</para>
	    						<list class="bullet">
			    					<listItem><para>
			    						<externalLink>
										    <linkText>VMWare Player</linkText>
										    <linkAlternateText>https://my.vmware.com/web/vmware/free#desktop_end_user_computing/vmware_player/6_0</linkAlternateText>
										    <linkUri>https://my.vmware.com/web/vmware/free#desktop_end_user_computing/vmware_player/6_0</linkUri>
										</externalLink>
			    					</para></listItem>
			    					<listItem><para>
			    						<externalLink>
										    <linkText>VirtualBox</linkText>
										    <linkAlternateText>https://www.virtualbox.org/</linkAlternateText>
										    <linkUri>https://www.virtualbox.org/</linkUri>
										</externalLink>
			    					</para></listItem>
	    						</list>
	    					</listItem>
	    					<listItem>
	    						<para>
	    							Emulators (if not running on x86 hardware):
	    						</para>
	    						<list class="bullet">
			    					<listItem><para>
			    						<externalLink>
										    <linkText>Qemu</linkText>
										    <linkAlternateText>http://wiki.qemu.org/</linkAlternateText>
										    <linkUri>http://wiki.qemu.org/</linkUri>
										</externalLink>
			    					</para></listItem>	    						
	    						</list>
	    					</listItem>
	    				</list>
	    				<para>
	    					Please note: At the time of writing, Fling OS primarily used VMWare Player for testing.
          				</para>
          			</content>
          		</section>
          	</sections>
      	  </section>
      	  
      	  
      	  <section address="CPUArchitecture_ARMArchitecture">
          	<title>ARM Architecture</title>
          	<sections>
          		<section address="CPUArchitecture_ARMArchitecture_BriefSummary">
          			<title>Brief summary of key details</title>
          			<sections>
          				<section address="CPUArchitecture_ARMArchitecture_BriefSummary_Origin">
          					<title>Origin - ARM</title>
          					<content>
								<para>
									The ARM architecture originates from the first ARM CPU created by Acorn Computers (the design team later became
				    		 		what is now known as ARM Holdings). ARM was first created in 1985, the same year that the 32-bit version of x86 
				    		 		was introduced (sources: Wikipedia, "ARM Architecture" and "x86" pages, as of 2014-09-16). Prior to what we know
				    		 		as the ARM architecture, the ARM development team created the very successful CPU as part of the BBC Micro. ARM2
				    		 		was the first ARM architecture CPU produced and became available in 1986. Since then, the architecture has gone
				    		 		through a number of revisions but has broadly retained the simple instruction set and core design principles.
					    		</para>
          					</content>
          				</section>
          				<section address="CPUArchitecture_ARMArchitecture_BriefSummary_History">
          					<title>A lot of history = very little baggage (see RISC)</title>
          					<content>
          						<para>
				    		 		Despite ARMs long history, they have relatively little "baggage" in the architecture (unlike x86, for example). 
				    		 		The ARM architecture has had three major advantages:
				    		 	</para>
				    		 	<list class="ordered">
				    		 		<listItem><para>
				    		 			They had the opportunity to learn from the several years of mistakes that Intel and x86 had made
				    		 			with 16-bit to 32-bit changes and similar ideas.
				    		 		</para></listItem>
				    		 		<listItem><para>
				    		 			The nature of the markets they were selling to (Apple, Mobile, embedded) meant they could afford to
										produce completely new revisions of the architecture which contained breaking changes compared to 
										previous architectures. This meant they could ditch some of the "baggage" along the way and so have a
										comparatively less cluttered architecture.
				    		 		</para></listItem>
				    		 		<listItem><para>
				    		 			RISC design principles keep things simple. Since the ARM architecture was designed to have simple single-step
			    		 			   instructions, every op is easy to understand and use. There is also less dependency between ops due to their
			    		 			   simpler nature requiring less setup prior to the op. Consequently, the architecture has remained fairly easy 
			    		 			   to understand and uncluttered.
				    		 		</para></listItem>
				    			</list>
          					</content>
          				</section>
          				<section address="CPUArchitecture_ARMArchitecture_BriefSummary_StandardForEmbeddedDevices">
          					<title>Standard for embedded devices</title>
          					<content>
          						<para>
				    		 		ARM CPUs have become the standard for embedded, mobile and tablet devices, having a clear majority of the 
				    		 		market in 2014. This is because of ARM CPUs' low-power, small-size and low-heat properties (which are a virtue
				    		 		of the RISC design principles). It is also worth noting ARM was selected by the Raspberry Pi developers as their
				    		 		CPU again for its low-cost, low-power, low-heat and high support by Linux. (There may be other reasons but these
				    		 		are the obvious ones).
          						</para>
          					</content>
          				</section>
          				<section address="CPUArchitecture_ARMArchitecture_BriefSummary_RISC">
          					<title>Simple instruction set (see RISC)</title>
          					<content>
          						<para>
				    		 		ARM is a RISC architecture (discussed later in this article) which means it has a simple instruction set
				    		 		which makes it easy to learn, easy to write ASM for and easier to write a compiler for than its x86 32 and 64-bit 
				    		 		counterparts. However, because of its simple (single-step) instructions, a lot more operations must be performed to 
				    		 		complete the same task (in comparison to an equivalent implementation on a CISC architecture such x86). This is 
				    		 		discussed in more detail in RISC vs CISC later in this article.
	    						</para>
          					</content>
          				</section>
          				<section address="CPUArchitecture_ARMArchitecture_BriefSummary_ManyGeneralPurposeRegisters">
          					<title>Lots of general purpose registers</title>
          					<content>
          						<para>
				    		 		The ARM architecture has a lot of general purpose registers, some of which are grouped into slightly more specific
				    		 		uses. This is useful to assembler programmers and compielr programmers as it offers a lot of freedom when writing
				    		 		code. This reduces headaches when writing code, in comparison to x86, as less must be placed on the stack as 
				    		 		temporarily storage. This, in turn, improves performance as register access is, generally, faster than memory
				    		 		access.
	    						</para>
          					</content>
          				</section>
          				<section address="CPUArchitecture_ARMArchitecture_BriefSummary_PagedVirtualMemory">
          					<title>Paged virtual memory</title>
          					<content>
          						<para>
          							There are many variations of the ARM architecture since ARM have produced many CPUs for many different environments.
				    		 		However, the main 32 and 64-bit ones aimed at mobile, tablet, laptop and desktop computing support paged virtual 
				    		 		memory. Note: This may not be true in all cases but it's a reasonable guide. If you think this is a bad guide, please
				    		 		let me know and suggest alternative, more accurate information.
	    						</para>
          					</content>
          				</section>
          				<section address="CPUArchitecture_ARMArchitecture_BriefSummary_WhatEndianness">
          					<title>What endianness?</title>
          					<content>
          						<para>
          							As mentioned in the previous section, there have been many variations of the ARM architecture. The endianness is
				    		 		model specific and so is classed as variable. You should try to write your code in a generic way so far as possible.
				    		 		When it is not possible, you will need to check the model of CPU on which you intend to test (/run) your code.
	    						</para>
          					</content>
          				</section>
          				<section address="CPUArchitecture_ARMArchitecture_BriefSummary_64Or32Bit">
          					<title>64-bit is simple extension of 32-bit so easy to learn either</title>
          					<content>
          						<para>          							
				    		 		Due to the simplicity of the RISC architecture, 64-bit is a simple extension of the 32-bit version which makes learning
				    		 		the 32 and 64-bit version equally easy. This is very different from, for example, the x86 architecture. This gives
				    		 		ARM an advantage over x86 from a developer's perspective.
	    						</para>
          					</content>
          				</section>
          				<section address="CPUArchitecture_ARMArchitecture_BriefSummary_FewerResources">
          					<title>Fewer resources and examples for ARM</title>
          					<content>
          						<para>          							
				    		 		Despite the ease of learning, ARM has far fewer resources for hobby developers. This is probably due to the fact 
				    		 		that x86 is easier to develop for, so hobby OS'es target x86 so resources are created for x86 development. This
				    		 		is somewhat of a perpetual cycle which ever reinforces the x86 development resources. ARM, however, have caught 
				    		 		a lucky break with the Raspberry Pi including it, forcing lots of developers to reconsider their choice. Combined
				    		 		with the growing mobile and tablet markets, which largely contain ARM, (hobby) developers are slowly shifting focus
				    		 		to ARM from x86.
	    						</para>
          					</content>
          				</section>
          				<section address="CPUArchitecture_ARMArchitecture_BriefSummary_HarderToTest">
          					<title>Harder to test</title>
          					<content>
          						<para>
          							ARM is significantly harder to test on for three primary reasons:
				    		 	</para>
	    						<list class="ordered">
	    							<listItem><para>
	    								ARM-based hardware is pretty hard to get hold of cheaply (ignoring the exceptional Raspberry Pi).
	    				   			</para></listItem>
	    							<listItem><para>
	    								Without ARM hardware, you are stuck with using emulators not VMs which are slow and less convenient to use.
	    				   			</para></listItem>
	    							<listItem><para>
	    								Since every ARM processor is different and not all are ASM compatible, you have to develop for one specific
			    		 				branch of processors which is more constraining than x86.
	    				   			</para></listItem>
	    						</list>
				    		 	<para>
				    		 		(Also, it's a lot cooler to be able to boot your OS on anyone's PC than messing around with (and probably damaging)
				    		 		 their phone.)
	    						</para>
          					</content>
          				</section>
          				<section address="CPUArchitecture_ARMArchitecture_BriefSummary_RISCArchitecture">
          					<title>RISC Architecture</title>
          					<content>
          						<para>
    		 						As has been mentioned, the ARM processor is a RISC architecture, which is discussed in more detail later.
          						</para>
	    					</content>
          				</section>
          			</sections>
          		</section>
          	</sections>
      	  </section>
      	  
      	  <section address="CPUArchitecture_RISCvsCISC">
          	<title>RISC vs CISC</title>
          	<sections>
          		<section address="CPUArchitecture_RISCvsCISC_AcronymMeanings">
          			<title>Acronym meanings</title>
          			<content>
          				<para>
          					Reduced Instruction Set Computing (RISC) and Complex Instruction Set Computing (CISC) are opposing design ideologies
	    					applied to the design of computer architecture. 
          				</para>
          				<para>
			    			RISC follows the general principle of defining as simple instructions as possible to keep each instruction single-step
			    			making them run very fast. CISC, however, follows the general principle of defining multi-step, specialist ops wherever 
			    			possible to create a complex but fast instruction set. There are no precise definitions of what constitutes RISC and 
			    			CISC nor where the boundary between them lies. The two concepts are best understood in tandem by comparing their
			    			differences.
          				</para>
          				<para>
			    			Examples of RISC designs are ARM processors. An example of CISC design is the x86 processor. ARM vs. x86 is a very 
			    			similar but subtly different debate discussed after this RISC vs. CISC debate.
          				</para>
          			</content>
          		</section>
          		
          		<section address="CPUArchitecture_RISCvsCISC_KeyDifferences">
          			<title>Key differences between the two</title>
          			<content>
          				<para>
          					(Please note: op = operation = instruction)
          				</para>
          				<list class="bullet">
          					<listItem>
          						<para>
          							RISC ops are single-step, CISC ops are multi-step
          						</para>
          						<para>
          							RISC operations are single-step meaning they only do one thing such as a single load from memory or a single
				    				numerical operation like add. CISC operations are multi-step meaning they do complex processes such as
				    				load a value from memory, add it to a register and store the result all in one overall operation.
          						</para>
          					</listItem>
          					<listItem>
          						<para>
          							RISC ops require fewer clock cycles than CISC ops
          						</para>
          						<para>
          							CISC ops are multi-step so take longer to run with more sub-operations than RISC's single-step ops. This
    								means CISC ops take more clock cycles to run than RISC ops.
          						</para>
          					</listItem>
          					<listItem>
          						<para>
          							CISC ops accomplish more
          						</para>
          						<para>
          							CISC ops are multi-step so complete more in one single operation than a single RISC op. This means fewer
				    				CISC ops are required to complete an overall task than the equivalent required RISC ops. This offsets the
				    				extra time a single CISC op takes compared to a RISC op. The two designs are a trade-off between instruction
				    				speed and instruction efficiency. This has been neatly summarised by this equation:
				    			</para>
				    			<pre>
				    					(time / program) = (time / instruction) * (instructions / program)
				    			</pre>
				    			<para>
				    				(Adapted from http://cs.stanford.edu/people/eroberts/courses/soco/projects/risc/risccisc/, 2014-09-16)
				    			</para>
          					</listItem>
          					<listItem>
          						<para>
          							RISC ops require fewer transistors than CISC ops
          						</para>
          						<para>
          							A typical RISC op requires far fewer transistors (in hardware) than CISC ops because of their reduced 
				    				design. This means RISC ops take up less physical silicon and less power (which also means, they create 
				    				less heat).
          						</para>
          					</listItem>
          					<listItem>
          						<para>
          							RISC ops are (usually) encoded in a uniform format, CISC are not
          						</para>
          						<para>
          							Since RISC ops are all fairly simple, requiring a minimum of parameters, every op can be encoded in a small
				    				amount of data thus meaning it is inexpensive to encode every op in the same amount of data. For example,
				    				some ARM processors encode all operations as 32-bits of data. CISC operations use anything from 0 to many 
				    				parameters and the nature of complex ops means that CISC tends to be encoded using a variable op-size format.
				    				Overall, this means RISC uses more program data than CISC does due to:
          						</para>
          						<list class="ordered">
          							<listItem><para>
          								Total size of the same number of RISC ops is, on average, slightly bigger then or the same as CISC ops
			    					   (there is some debate on how to measure this).
			    					</para></listItem>
			    					<listItem><para>
			    						Total number of ops for RISC is much greater than CISC (this is well-known and accepted) meaning the
			    					   	number of encoded ops is much greater so the total data size is much greater.
			    					</para></listItem>
          						</list>
          					</listItem>
          					<listItem>
          						<para>
          							RISC has simple addressing modes, CISC has complex modes
          						</para>
          						<para>
				    				RISC ops are simple, with only a few operations able to perform load / store operations. This means that 
				    				addressing modes are very simple as you are either accessing a register, or the op treats the register value as
				    				an address (but that decision is based on the op not the parameter). CISC, on the other hand, has more complex 
				    				addressing modes where parameters can be treated as registers or addresses to memory along with variations and
				    				combinations on top of this. The overall result is CISC has complex sets of addressing possibilities. This can
				    				make CISC assembly code complex to read, difficult to understand and prone to errors.
          						</para>
          					</listItem>
          					<listItem>
          						<para>
          							RISC has fewer hardware data types
				    			</para>
          						<para>
          							The simpler nature of RISC ops means fewer hardware data types are required by the architecture. This makes
				    				assembly code simpler to understand but does mean software data types are even more abstracted from the 
				    				hardware representations.
          						</para>
          					</listItem>
          					<listItem>
          						<para>
          							RISC requires only instruction pointer to describe state, CISC requires hidden state information
				    			</para>
          						<para>
          							RISC ops a single-step and simple so there is (virtually) no temporary caching of state during an operation. This
				    				means you could restart an operation without requiring any state restoration. This means that the only thing 
				    				required to know the state of a program in a RISC architecture is the instruction pointer and register values.
				    				CISC, on the other hand, has lots of state caching during long, complex operations which means that you cannot
				    				restart an op without restoring values from the temporary data stores. However, these hardware data stores are 
				    				usually not accessible to the developer. This means that even if you know the instruction point at a given moment,
				    				you do not know the full state of the processor and by extension, the program.
          						</para>
          					</listItem>
    					</list>
          			</content>
          		</section>
          		
          		<section address="CPUArchitecture_RISCvsCISC_BriefNote1">
          			<title>Brief note</title>
          			<content>
          				<para>
			    			The following are a brief summary of the advantages and disadvantages of RISC vs. CISC from my research of the topic.
			    			This topic has been highly debated over the years and there are many articles available through a simple search of
			    			"RISC vs. CISC" that give a more in-depth discussion (and justification) of the various stand points. 
          				</para>
          			</content>
          		</section>
          		
          		<section address="CPUArchitecture_RISCvsCISC_AdvantagesOfRISC">
          			<title>Advantages of RISC</title>
          			<content>
          				<list class="bullet">
          					<listItem><para>
		    					Architecture and assembler is simpler to learn
		    				</para></listItem>
		    				<listItem><para>
		    					Assembler is easier to read
		    				</para></listItem>
		    				<listItem><para>
		    					Can have a simpler compiler
		    				</para></listItem>
		    				<listItem><para>
		    					Requires less silicon
		    				</para></listItem>
		    				<listItem><para>
		    					Thus less power and less physical space
		    				</para></listItem>
		    				<listItem><para>
		    					And also less heat, meaning no heat sync (which are not possible in embedded, mobile and tablet applications)
		    				</para></listItem>
          				</list>
          			</content>
          		</section>
          		
          		<section address="CPUArchitecture_RISCvsCISC_AdvantagesOfCISC">
          			<title>Advantages of CISC</title>
          			<content>
          				<list class="bullet">
          					<listItem><para>
          						Can do complex data handling faster / more efficiently
		    				</para></listItem>
		    				<listItem><para>
		    					Requires fewer lines of assembler (improves compile time &amp; efficiency)
		    				</para></listItem>
		    				<listItem><para>
		    					Easier for programmer to program more complex data handling (in assembler)
		    				</para></listItem>
		    				<listItem><para>
		    					Requires fewer general purpose registers
		    				</para></listItem>
          				</list>
          			</content>
          		</section>
          		
          		<section address="CPUArchitecture_RISCvsCISC_DisadvantagesOfRISC">
          			<title>Disadvantages of RISC</title>
          			<content>
          				<list class="bullet">
          					<listItem><para>
		    					Has simpler instructions thus requiring more lines of assembler for the same, overall complex operation
		    				</para></listItem>
		    				<listItem><para>
		    					Can be less efficient compared to a CISC architecture optimised for your task
		    				</para></listItem>
		    				<listItem><para>
		    					More onus on the programmer to figure out how to organise complex data handling
		    				</para></listItem>
		    				<listItem><para>
		    					Requires many general purpose registers
		    				</para></listItem>
          				</list>
          			</content>
          		</section>
          		
          		<section address="CPUArchitecture_RISCvsCISC_DisadvantagesOfCISC">
          			<title>Disadvantages of CISC</title>
          			<content>
          				<list class="bullet">
          					<listItem><para>
          						Architecture and assembler is harder to learn
		    				</para></listItem>
		    				<listItem><para>
		    					Assembler can be harder to read
		    				</para></listItem>
		    				<listItem><para>
		    					Requires a more complex compiler to really make use of the advantages of CISC
		    				</para></listItem>
		    				<listItem><para>
		    					Requires more silicon
		    				</para></listItem>
		    				<listItem><para>
		    					Thus more power and more physical space
		    				</para></listItem>
		    				<listItem><para>
		    					And more heat is produced, requiring a heat sync which makes the processor bulky
		    				</para></listItem>
          				</list>
          			</content>
          		</section>
          		
          		<section address="CPUArchitecture_RISCvsCISC_Conclusion">
          			<title>Conclusion</title>
          			<content>
          				<para>
	          				Here follows my own conclusions from the RISC vs. CISC debate. I have found I agree with the widely popular 
		    				opinions:
	    				</para>
	    				<list class="bullet">
          					<listItem><para>
	    						RISC is simpler, easier to learn and use
		    				</para></listItem>
		    				<listItem><para>
	    						RISC is usually lower power
		    				</para></listItem>
		    				<listItem><para>
	    						CISC is faster, more powerful
		    				</para></listItem>
		    				<listItem><para>
	    						Both are useful for a given specific purpose. You must pick the correct architecture for the job.
		    				</para></listItem>
		    				<listItem><para>
	    						RISC is (slightly) more recent and generally liked more so is perhaps better
		    				</para></listItem>
		    				<listItem><para>
	    						However, x86 still more common than ARM in PCs so CISC is more accessible
		    				</para></listItem>
		    				<listItem><para>
	    						Overall, I would prefer RISC if it weren't for its practical difficulty to develop for.
		    				</para></listItem>
	    				</list>
	    				<para>
		    				It should be noted that the top-end RISC CPUs and top-end CISC CPUs have both borrowed ideas from each other's
		    				designs meaning top-end RISC and CISC CPUs are almost indistinguishable in terms of RISC/CISC. It has become
		    				increasingly meaningless to say a CPU is RISC or CISC. The only true remaining CISC architecture is the x86 CPU
		    				which Intel appear to be trying to replace as they push into mobile and embedded markets.
		    			</para>
          			</content>
          		</section>          		
          	</sections>
          </section>
          
          <section address="CPUArchitecture_ARMvsx86">
          	<title>ARM vs x86</title>
          	<sections>
          		<section address="CPUArchitecture_ARMvsx86_DrawingFromRISCvsCISC">
          			<title>Drawing from RISC vs CISC</title>
          			<content>
          				<para>
          					The RISC vs. CISC debate is largely ARM vs. x86 in the modern, high-power devices such as mobiles, tablets,
		    				laptops and, of course, PCs. ARM broadly, wins for low power and space efficiency but x86 wins for high power 
		    				and performance.
          				</para>
          			</content>
          		</section>
          		
          		<section address="CPUArchitecture_ARMvsx86_BriefNote1">
          			<title>Brief Note</title>
          			<content>
          				<para>          					
          					The following is a brief summary of the main points commonly put forward in the x86 vs ARM debate.
          				</para>
          			</content>
          		</section>
          		
          		<section address="CPUArchitecture_ARMvsx86_AdvantagesOfARM">
          			<title>Advantages of ARM</title>
          			<content>
          				<list class="bullet">  
          					<listItem><para>
          						All the advantages of RISC
          					</para></listItem>
          					<listItem><para>
		    					In the Raspberry Pi which actually breaks down the high-cost / low-accessibility barrier
          					</para></listItem>
          					<listItem><para>
		    					Rapidly growing as mobile and tablet become prolific so supporting it is very good and future-proof.
          					</para></listItem>
          				</list>
          			</content>
          		</section>
          		
          		<section address="CPUArchitecture_ARMvsx86_AdvantagesOfx86">
          			<title>Advantages of x86</title>
          			<content>
          				<list class="bullet">
          					<listItem><para>
          						All the advantages of CISC
          					</para></listItem>
          					<listItem><para>
		    					It's in almost every PC making it easy to test and develop for
          					</para></listItem>
          					<listItem><para>
		    					Lots of development resources, examples and tutorials
          					</para></listItem>
          					<listItem><para>
		    					Virtual machines are faster
          					</para></listItem>
          					<listItem><para>
		    					Easier to develop for initially
          					</para></listItem>
          					<listItem><para>
		    					More compilers
          					</para></listItem>
          					<listItem><para>
		    					You can develop x86 on any platform including Windows. Developing for ARM on Windows is still a little
		    				  	difficult, primarily due to lack of tools for testing / development which support ARM.
          					</para></listItem>
          				</list>
          			</content>
          		</section>
          		
          		<section address="CPUArchitecture_ARMvsx86_DisadvantagesOfARM">
          			<title>Disadvantages of ARM</title>
          			<content>
          				<list class="bullet">
          					<listItem><para>
          						All the disadvantages of RISC
          					</para></listItem>
          					<listItem><para>
		    					Hard to access hardware (excl. RPi)
          					</para></listItem>
          					<listItem><para>
		    					Hard to set up initially
          					</para></listItem>
          					<listItem><para>
		    					Often must use emulator or you're stuck with Linux on an ARM chip which not all developers like
          					</para></listItem>
          					<listItem><para>
		    					Development tools often limited to Linux only
          					</para></listItem>
          				</list>
          			</content>
          		</section>
          		
          		<section address="CPUArchitecture_ARMvsx86_DisadvantagesOfx86">
          			<title>Disadvantages of x86</title>
          			<content>
          				<list class="bullet">
          					<listItem><para>
          						All the disadvantages of CISC
          					</para></listItem>
          					<listItem><para>
		    					More complex to learn advanced operations so you can't really take advantage of the x86 CPU.
          					</para></listItem>
          					<listItem><para>
		    					Soon to be outdated if you stick to only 32-bit. Intel and AMD are likely to move further away from
		    				  	x86 (32 or 64-bit) as they attempt to penetrate the mobile, tablet and embedded markets.
          					</para></listItem>
          				</list>
          			</content>
          		</section>
          		
          		<section address="CPUArchitecture_ARMvsx86_Conclusion">
          			<title>Conclusion</title>
          			<content>
          				<para>      
          					x86 wins only because it is currently easier to develop for, but if you have the time &amp; effort, 
          					ARM would be well worth learning
          				</para>
          			</content>
          		</section>
          	</sections>
          </section>
          
          <section address="CPUArchitecture_AssemblerSyntaxes">
          	<title>Assembler Syntaxes</title>
          	<sections>
          		<section address="CPUArchitecture_AssemblerSyntaxes_General">
          			<title>General</title>
          			<content>
          				<para>
          					There are a number of different syntaxes used for writing assembly code. Which you use is determined by your
		    				compiler. The syntax used by Fling OS is primarily NASM (since Fling OS uses the NASM compiler). 
		    				
		    				Which assembler you use is determined by you compiler. Which compiler you used is broadly determined by:
		    			</para>
		    			<list class="ordered">
		    					<listItem><para>Does the compiler support the architecture you wish to target?</para></listItem>
		    					<listItem><para>Do you want/need a compiler capable of cross-platform compiling?</para></listItem>
		    					<listItem>
		    						<list class="ordered">
		    							<listItem><para>Does the compiler integrate with your toolchain easily?</para></listItem>
		    							<listItem><para>Do you like the compiler's ASM syntax?</para></listItem>
		    						</list>
		    					</listItem>
		    			</list>
		    			<para>
		    				(1) and (2) are necessary choices that you must make. (3) are choices which are entirely personal preference.
		    				Most assembler compilers have existed for a long time so are stable, well documented and will integrate with 
		    				at least one environment very well.
          				</para>
          			</content>
          		</section>
          		<section address="CPUArchitecture_AssemblerSyntaxes_NASMMASMGAS">
          			<title>NASM, MASM, GAS</title>
          			<content>
          				<para>
          					NASM (Netwide Assembler) is an x86 assembler which uses an Intel-like syntax. Alternative compilers/syntaxes 
		    				include MASM (Microsoft Macro Assembler), which uses Intel syntax, and another is GAS (GNU Assembler) which 
		    				is a cross-platform assembler used by the GNU project. It is worth repeating: NASM and MASM are x86 assemblers 
		    				only. If you intend to target ARM, you will not be able to use NASM or MASM.
          				</para>
          			</content>
          		</section>
          		<section address="CPUArchitecture_AssemblerSyntaxes_InlineAssembler">
          			<title>Inline assembler</title>
          			<content>
          				<para>
          					While writing your OS you may need (or just want) to write assembler in with your main code. High-level languages,
		    				such as C#, do not permit this (for a variety of reasons). If your language does not support inline assembler, 
		    				then working around it is left to you to do. If your language does support inline assembler (such as C) then 
		    				which assembler syntax you use is, as before, dependent upon your compiler. You will need to look up the spec
		    				for your language implementation (such as MS-C) to find out how to write inline assembler in a way the compiler
		    				will understand.
          				</para>
          			</content>
          		</section>
          	</sections>
          </section>
          
          <section address="CPUArchitecture_NASM">
          	<title>NASM</title>
          	<sections>
          		<section address="CPUArchitecture_NASM_Notes">
          			<title>Notes about NASM &amp; Fling OS</title>
          			<content>
          				<para>
		    				As previously mentioned, Fling OS uses the NASM compiler and thus NASM syntax. Assembler samples are given in
		    				NASM syntax. If you are using a different syntax, you must be very careful when converting samples. Particular
		    				attention should be paid to parameter order, since a failure to switch parameters will entirely break code.
          				</para>
          			</content>
          		</section>
          		
          		<section address="CPUArchitecture_NASM_Examples">
          			<title>A few examples</title>
          			<content>
          				<code lang="" numberLines="true" tabSize="4">
		    				- - - - - - - - - - - - - - - - 32-bit Addition - - - - - - - - - - - - - - - -
		    				
		    				; This sample adds two numbers and stores the result over one of the first input
		    				
		    				mov eax, 1      ; Load the first number to add
		    				mov ebx, 1      ; Load the second number to add
		    				add eax, ebx    ; Add the two numbers, result stored in eax
		    				
		    			</code>
		    			<code lang="" numberLines="true" tabSize="4">
		    				- - - - - - - - - - - - - - - 32-bit Port Output - - - - - - - - - - - - - - - -
		    				
		    				; This sample outputs a 32-bit value to an IO port
		    				mov eax, 0xDEADBEEF     ; Load the value to send
		    				out 0xF0, eax           ; Output the value to port 0xF0
		    				
		    			</code>
		    			<code lang="" numberLines="true" tabSize="4">
		    				- - - - - - - - - - - - - - - - Conditional Branching - - - - - - - - - - - - - - - -
		    				
		    				; This sample loads a number then tests whether it is greater than a specified number.
		    				;   If it is greater, it stores 0 in the primary general purpose register
		    				;   If it is equal or less, it stores a 1 in the primary general purpose register.
		    				; Execution then continues at a common point.
		    				
		    				; Note: The greater-than test is a signed test
		    				
		    				mov eax, 1      ; Load the number to test against
		    				cmp eax, 10     ; Compare the test number (in eax) to the condition value (10)
		    				jg GreaterThan  ; Jump to the GreaterThan label (defined below) if eax > 10
		    				mov eax, 1      ; Less than or equal so store 1
		    				jmp CommonCode  ; Then jump to the common code (skipping then GreaterThan code so we don't overwrite the
		    				                ; 1 that we just stored).
		    				GreaterThan:    ; Define the GreaterThan label - this defines a point in the program we can jump to.
		    				mov eax, 0      ; Greater than so store 0
		    				     ; No need to jump to CommonCode - execution will continue to the next line regardless.
		    				CommonCode:    ; Define the common code label
		    				; Execution continues here
		    				
		    			</code>
          			</content>
          		</section>
          		
          		<section address="CPUArchitecture_NASM_Links">
          			<title>Links</title>
          			<content>
          				<para>
          					All links valid as of 2014-09-17
          				</para>
          				<list class="bullet">
          					<listItem>
								<externalLink>
							    	<linkText>NASM Website</linkText>
							        <linkAlternateText>http://www.nasm.us</linkAlternateText>
							        <linkUri>http://www.nasm.us</linkUri>
								</externalLink>
							</listItem>
							<listItem>
								<externalLink>
							    	<linkText>Netwide Assembler (Wikipedia)</linkText>
							        <linkAlternateText>http://en.wikipedia.org/wiki/Netwide_Assembler</linkAlternateText>
							        <linkUri>http://en.wikipedia.org/wiki/Netwide_Assembler</linkUri>
								</externalLink>
							</listItem>
							<listItem>
								<externalLink>
							    	<linkText>NASM Examples (Loyola Marymount University)</linkText>
							        <linkAlternateText>http://cs.lmu.edu/~ray/notes/nasmexamples/</linkAlternateText>
							        <linkUri>http://cs.lmu.edu/~ray/notes/nasmexamples/</linkUri>
								</externalLink>
							</listItem>
							<listItem>
								<externalLink>
							    	<linkText>Bare Bones with NASM (OSDev)</linkText>
							        <linkAlternateText>http://wiki.osdev.org/Bare_Bones_with_NASM</linkAlternateText>
							        <linkUri>http://wiki.osdev.org/Bare_Bones_with_NASM</linkUri>
								</externalLink>
							</listItem>
    					</list>
          			</content>
          		</section>
          	</sections>
          </section>
      </sections>
    </section>
    
    
    <section address="CPUsAsDevices">
      <title>CPUs As Devices</title>
      <sections>
          <section address="CPUsAsDevices_Overview">
              <title>Overview</title>
              <content>
                  <para>
                  	The CPU as a target architecture has been discussed fairly thoroughly above. This section covers
	   				the CPU as a device.
	   			  </para>
	   			  <para>
	   				While your operating system is running, the CPU is the primary device you must manage. Most of the
	   				time it acts transparently or as part of your program (e.g. stack and instruction pointer management).
	   				Occasionally, however, you will need to give the CPU specific control instructions to tell it what to
	   				do or what to set up. Examples of these cases are when the OS first boots, setting up the segmentation 
	   				registers and later when you program process switching, handling paged virtual memory.
	   			  </para>
	   			  <para>
	   				The following sections provide details of:
	   			  </para>
	   			  <list class="bullet">
	   				<listItem><para>
	   					General features supported by the majority of CPUs which are useful (or necessary) when managing the CPU.
	   				</para></listItem>
	   				<listItem><para>x86 specific code samples for some of the general features</para></listItem>
                  </list>
              </content>
          </section>
          
          <section address="CPUsAsDevices_GeneralFeatures">
              <title>General features</title>
              <sections>
              	  <section address="CPUsAsDevices_GeneralFeatures_ID">
		              <title>ID</title>
		              <content>
		              	<para>
		              		Most CPUs support some form of ID either in the form of an operation or a register. A CPU ID can take
		    				various forms. One of these forms is a revision number, in which case you will need to check the
		    				manufacturer website for specific version information. Another form is a bit-field that supplies
		    				information about what the CPU supports. You will need to look at the manufacturer website to know
		    				what each bit means, but after that you can write generic code that works across different (including 
		    				new) CPU versions without adding extra CPU IDs.
		              	</para>
		              </content>
		          </section>
		          
              	  <section address="CPUsAsDevices_GeneralFeatures_HaltReset">
		              <title>Halt / Reset</title>
		              <content>
		              	<para>
		              		All CPUs support a Halt / Reset feature that allows you to programmatically stop or restart the CPU.
		    				If you stop the CPU, the only events which will cause the CPU to resume are:
		    			</para>
		    			<list class="bullet">
		    				<listItem><para>A non-maskable interrupt occurs</para></listItem>
		    				<listItem><para>An unmasked maskable-interrupt occurs</para></listItem>
		    				<listItem><para>Power to the CPU is cycled</para></listItem>
		    			</list>
		    			<para>
		    				CPU halt is useful for implementing CPU sleep functionality. You can stop the CPU from executing until
		    				a timer interrupt occurs thus allowing you to wait for a short period of time without using a (busy-)loop. 
		    			</para>
		    			<para>
		    				CPU reset is implemented in a number of ways. For example, the PS2 keyboard reset line has been a 
		    				long-standing way to hard reset the CPU of a PC. Reset is also achieved through reset ops or the ACPI 
		    				features.
		              	</para>
		              </content>
		          </section>
		          
              	  <section address="CPUsAsDevices_GeneralFeatures_Speed">
		              <title>Speed</title>
		              <content>
		              	<para>
		              		Most modern CPUs support a way of determining the speed of the CPU. This speed can be in clock-frequency,
		    				clock-interval or potentially some other measurement. The speed of the CPU is useful in time-based functions
		    				such as CPU time allocation and for outputting to the user, so they can show it off to their mates ;)
		              	</para>
		              </content>
		          </section>
		          
              	  <section address="CPUsAsDevices_GeneralFeatures_MultipleCPUsMulticore">
		              <title>Multiple CPUs / Multicore</title>
		              <content>
		              	<para>
		              		For CPUs which have multiple cores or which are designed to work in parallel with other CPUs, functions for
		    				synchronising cores, transferring data consistently and other necessary cross-core / cross-CPU functions 
		    				will be provided.
		              	</para>
		              </content>
		          </section>
              </sections>
          </section>
          
          <section address="CPUsAsDevices_x86">
              <title>x86</title>
              <sections>
              	  <section address="CPUsAsDevices_x86_ID">
		              <title>ID</title>
		              <content>
		              	<para>
		              		x86 specific example code to be added.
		              	</para>
		              </content>
		          </section>
		          
              	  <section address="CPUsAsDevices_x86_Halt">
		              <title>Halt</title>
		              <content>
		              	<para>
		              		x86 specific example code to be added.
		              	</para>
		              </content>
		          </section>
		          
              	  <section address="CPUsAsDevices_x86_Reset">
		              <title>Reset</title>
		              <content>
		              	<para>
		              		x86 specific example code to be added.
		              	</para>
		              </content>
		          </section>
		      </sections>
		  </section>
      </sections>
    </section>
        
	<section address="References">
	  <title>References</title>
	  <content>			   
	  	<para>
	  		The following links are additional references to those supplied within the main body of the article.
	  	</para>
		<list class="ordered">
		  <listItem>
		  	<externalLink>
		          <linkText>OSDev.org - CPUID</linkText>
		          <linkAlternateText>OSDev.org - CPUID</linkAlternateText>
		          <linkUri>http://wiki.osdev.org/CPUID</linkUri>
		      </externalLink>
		  </listItem>
		  <listItem>
		  	<externalLink>
		          <linkText>OSDev.org - Reboot</linkText>
		          <linkAlternateText>OSDev.org - Reboot</linkAlternateText>
		          <linkUri>http://wiki.osdev.org/Reboot</linkUri>
		      </externalLink>
		  </listItem>
		  <listItem>
		  	<externalLink>
		          <linkText>Wikipedia - Intel/AMD x86 Architecture</linkText>
		          <linkAlternateText>Wikipedia - Intel/AMD x86 Architecture</linkAlternateText>
		          <linkUri>http://en.wikipedia.org/wiki/X86</linkUri>
		      </externalLink>
		  </listItem>
		  <listItem>
		  	<externalLink>
		          <linkText>Wikibooks - x86 Assembly &amp; Opcodes</linkText>
		          <linkAlternateText>Wikibooks - x86 Assembly &amp; Opcodes</linkAlternateText>
		          <linkUri>http://en.wikibooks.org/wiki/X86_Assembly</linkUri>
		      </externalLink>
		  </listItem>
		  <listItem>
		  	<externalLink>
		          <linkText>Bright Hub - ARM vs x86 Processors: What's the Difference?</linkText>
		          <linkAlternateText>Bright Hub - ARM vs x86 Processors: What's the Difference?</linkAlternateText>
		          <linkUri>http://www.brighthub.com/computing/hardware/articles/107133.aspx</linkUri>
		      </externalLink>
		  </listItem>
		  <listItem>
		  	<externalLink>
		          <linkText>Stanford Education - RISC vs. CISC</linkText>
		          <linkAlternateText>Stanford Education - RISC vs. CISC</linkAlternateText>
		          <linkUri>http://cs.stanford.edu/people/eroberts/courses/soco/projects/risc/risccisc/</linkUri>
		      </externalLink>
		  </listItem>
		  <listItem>
		  	<externalLink>
		          <linkText>ARM versus x86 - Considerations for the embedded segment</linkText>
		          <linkAlternateText>ARM versus x86 - Considerations for the embedded segment</linkAlternateText>
		          <linkUri>http://www.hectronic.se/website1/embedded/arm-versus-x86/arm-versus-x86.php</linkUri>
		      </externalLink>
		  </listItem>
		</list>
	  </content>
	</section>

	<section address="Revisions">
	  <title>Revisions</title>
	  <content>			   
	  	<para>
	  		The following is a list of all the revisions made to this document in order of first to last (oldest to newest).
	  	</para>
		<list class="ordered">
		  <listItem><para>25/09/14 - Inital version.</para></listItem>
		  <listItem><para>27/09/14 - Spelling and formatting corrections.</para></listItem>
		</list>
	  </content>
	</section>

    
    <relatedTopics>
      <!-- One or more of the following:
           - A local link
           - An external link
           - A code entity reference

      <link xlink:href="Other Topic's ID"/>
      <link xlink:href="Other Topic's ID">Link inner text</link>

      <externalLink>
          <linkText>Link text</linkText>
          <linkAlternateText>Optional alternate link text</linkAlternateText>
          <linkUri>URI</linkUri>
      </externalLink>

      <codeEntityReference>API member ID</codeEntityReference>

      Examples:

      <link xlink:href="00e97994-e9e6-46e0-b420-5be86b2f8270" />
      <link xlink:href="00e97994-e9e6-46e0-b420-5be86b2f8278">Some other topic</link>

      <externalLink>
          <linkText>SHFB on CodePlex</linkText>
          <linkAlternateText>Go to CodePlex</linkAlternateText>
          <linkUri>http://shfb.codeplex.com</linkUri>
      </externalLink>

      <codeEntityReference>T:TestDoc.TestClass</codeEntityReference>
      <codeEntityReference>P:TestDoc.TestClass.SomeProperty</codeEntityReference>
      <codeEntityReference>M:TestDoc.TestClass.#ctor</codeEntityReference>
      <codeEntityReference>M:TestDoc.TestClass.#ctor(System.String,System.Int32)</codeEntityReference>
      <codeEntityReference>M:TestDoc.TestClass.ToString</codeEntityReference>
      <codeEntityReference>M:TestDoc.TestClass.FirstMethod</codeEntityReference>
      <codeEntityReference>M:TestDoc.TestClass.SecondMethod(System.Int32,System.String)</codeEntityReference>
      -->
    </relatedTopics>
  </developerConceptualDocument>
</topic>