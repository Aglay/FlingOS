#region Copyright Notice
// ------------------------------------------------------------------------------ //
//                                                                                //
//               All contents copyright � Edward Nutting 2014                     //
//                                                                                //
//        You may not share, reuse, redistribute or otherwise use the             //
//        contents this file outside of the Fling OS project without              //
//        the express permission of Edward Nutting or other copyright             //
//        holder. Any changes (including but not limited to additions,            //
//        edits or subtractions) made to or from this document are not            //
//        your copyright. They are the copyright of the main copyright            //
//        holder for all Fling OS files. At the time of writing, this             //
//        owner was Edward Nutting. To be clear, owner(s) do not include          //
//        developers, contributors or other project members.                      //
//                                                                                //
// ------------------------------------------------------------------------------ //
#endregion
    
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Reflection;
using Kernel.Debug.Data;

namespace Kernel.Compiler
{
    /// <summary>
    /// Represents an IL scanner's current state (such as current method that is being scanned, Method IDs etc.)
    /// </summary>
    public class ILScannerState
    {
        /// <summary>
        /// The method to use as the kernel's Add Exception Handler Info method.
        /// </summary>
        public MethodBase AddExceptionHandlerInfoMethod;
        /// <summary>
        /// The method to use as the kernel's Handle Leave method.
        /// </summary>
        public MethodBase ExceptionsHandleLeaveMethod;
        /// <summary>
        /// The method to use as the kernel's Handle End Finally method.
        /// </summary>
        public MethodBase ExceptionsHandleEndFinallyMethod;
        /// <summary>
        /// The method to use as the kernel's GC New Obj method.
        /// </summary>
        public MethodBase NewObjMethod;
        /// <summary>
        /// The method to use as the kernel's GC New Arr method.
        /// </summary>
        public MethodBase NewArrMethod;
        /// <summary>
        /// The method to use as the kernel's GC Increment Ref Count method.
        /// </summary>
        public MethodBase IncrementRefCountMethod;
        /// <summary>
        /// The method to use as the kernel's GC Decrement Ref Count method.
        /// </summary>
        public MethodBase DecrementRefCountMethod;
        /// <summary>
        /// The method to use as the kernel's Halt method.
        /// </summary>
        public MethodBase HaltMethod;
        /// <summary>
        /// The method to use to throw a NullReferenceException.
        /// </summary>
        public MethodBase ThrowNullReferenceExceptionMethod;
        /// <summary>
        /// The method to use to throw a ArrayTypeMismatchException.
        /// </summary>
        public MethodBase ThrowArrayTypeMismatchExceptionMethod;
        /// <summary>
        /// The method to use to throw a IndexOutOfRangeException.
        /// </summary>
        public MethodBase ThrowIndexOutOfRangeExceptionMethod;

        /// <summary>
        /// The class to use as the kernel's Type class.
        /// </summary>
        public Type TypeClass;
        /// <summary>
        /// The class to use as the kernel's Array class.
        /// </summary>
        public Type ArrayClass;
        /// <summary>
        /// The class to use as the kernel's String class.
        /// </summary>
        public Type StringClass;
        /// <summary>
        /// The struct to use as the kernel's MethodInfo struct.
        /// </summary>
        public Type MethodInfoStruct;
        /// <summary>
        /// The struct to use as the kernel's FieldInfo struct.
        /// </summary>
        public Type FieldInfoStruct;

        /// <summary>
        /// Whether to do a debug build or not. Read-only - copied from Settings when IL scanner starts. 
        /// </summary>
        public readonly bool DebugBuild;

        /// <summary>
        /// The ASM chunk that contains the String Literals data (hard-coded string values generated by "AString" in C# code.)
        /// </summary>
        public ASMChunk StringLiteralsDataBlock = new ASMChunk();
        /// <summary>
        /// The ASM chunk that contains the Static Fields data.
        /// </summary>
        public ASMChunk StaticFieldsDataBlock = new ASMChunk();
        /// <summary>
        /// The ASM chunk that contains the Types Table data.
        /// </summary>
        public ASMChunk TypesTableDataBlock = new ASMChunk();
        /// <summary>
        /// The ASM chunk that contains the Methods Table data.
        /// </summary>
        public List<ASMChunk> MethodTablesDataBlock = new List<ASMChunk>();
        /// <summary>
        /// The ASM chunk that contains the Fields Table data.
        /// </summary>
        public List<ASMChunk> FieldTablesDataBlock = new List<ASMChunk>();
        
        /// <summary>
        /// The stack frame for the method currently being scanned.
        /// </summary>
        public StackFrame CurrentStackFrame = null;
        /// <summary>
        /// The IL chunk that is currently being scanned.
        /// </summary>
        public ILChunk CurrentILChunk;

        /// <summary>
        /// A dictionary of all the method signatures to method IDs scanned so far.
        /// </summary>
        private Dictionary<string, string> MethodIDs = new Dictionary<string, string>();
        /// <summary>
        /// A dictionary of all the method signatures to method ID values scanned so far.
        /// </summary>
        private Dictionary<string, string> MethodIDValues = new Dictionary<string, string>();
        /// <summary>
        /// A dictionary of all the field signatures to field IDs scanned so far.
        /// </summary>
        private Dictionary<string, string> StaticFieldIDs = new Dictionary<string, string>();
        /// <summary>
        /// A dictionary of all the types to type IDs scanned so far.
        /// </summary>
        private Dictionary<string, string> TypeIDs = new Dictionary<string, string>();
        
        /// <summary>
        /// Initialises a new, empty scanner state.
        /// </summary>
        public ILScannerState(bool debugBuild)
        {
            DebugBuild = debugBuild;

            InitStringLiteralsDataBlock();
            InitStaticFieldsDataBlock();
            InitTypesTablesDataBlock();
        }

        public int GetTypeFieldOffset(string FieldName)
        {
            DB_Type typeDBType = DebugDatabase.GetType(GetTypeID(TypeClass));
            return GetFieldOffset(typeDBType, FieldName);
        }
        public int GetFieldOffset(DB_Type dbType, string FieldName)
        {
            //Get the child links of the type (i.e. the fields of the type)
            List<DB_ComplexTypeLink> allChildLinks = dbType.ChildTypes.OrderBy(x => x.ParentIndex).ToList();
            //Get the DB type information for the field we want to load
            DB_ComplexTypeLink theTypeLink = (from links in dbType.ChildTypes
                                              where links.FieldId == FieldName
                                              select links).First();
            //Get all the fields that come before the field we want to load
            //This is so we can calculate the offset (in memory, in bytes) from the start of the object
            allChildLinks = allChildLinks.Where(x => x.ParentIndex < theTypeLink.ParentIndex).ToList();
            //Calculate the offset
            return allChildLinks.Sum(x => x.ChildType.IsValueType ? x.ChildType.BytesSize : x.ChildType.StackBytesSize);
        }

        private int currentMethodIDValue = 1;
        /// <summary>
        /// Gets the specified method's ID. If the method has not been scanned already, a new ID is created.
        /// </summary>
        /// <param name="aMethod">The method to get the ID of.</param>
        /// <returns>The method's ID.</returns>
        public string GetMethodID(MethodBase aMethod)
        {
            string methodSignature = Utils.GetMethodSignature(aMethod);
            string result = null;
            if (MethodIDs.ContainsKey(methodSignature))
            {
                result = MethodIDs[methodSignature];
            }
            else
            {
                result = Utils.CreateMethodID(methodSignature);
                MethodIDs.Add(methodSignature, result);
            }
            return result;
        }
        /// <summary>
        /// Gets the specified method's ID Value. If the method has not been scanned already, a new ID Value is created.
        /// </summary>
        /// <param name="aMethod">The method to get the ID Value of.</param>
        /// <returns>The method's ID Value.</returns>
        public string GetMethodIDValue(MethodInfo aMethod)
        {
            string methodSignature = Utils.GetMethodSignature(aMethod);
            string result = null;
            if (MethodIDValues.ContainsKey(methodSignature))
            {
                result = MethodIDValues[methodSignature];
            }
            else
            {
                //Check if method is actually an override
                // - If so, use the same method ID value as parent method
                MethodInfo baseDefMethod = aMethod.GetBaseDefinition();
                if (baseDefMethod != aMethod)
                {
                    result = GetMethodIDValue(baseDefMethod);
                }
                else
                {
                    result = (currentMethodIDValue++).ToString();
                }
                MethodIDValues.Add(methodSignature, result);
            }
            return result;
        }
        /// <summary>
        /// Gets the specified field's ID. If the field has not been scanned already, a new ID is created.
        /// </summary>
        /// <param name="aField">The field to get the ID of.</param>
        /// <returns>The field's ID.</returns>
        public string GetStaticFieldID(FieldInfo aField)
        {
            string fieldSignature = Utils.GetFieldSignature(aField);
            string result = null;
            if (StaticFieldIDs.ContainsKey(fieldSignature))
            {
                result = StaticFieldIDs[fieldSignature];
            }
            else
            {
                result = fieldSignature;
                result = "staticfield_" + Utils.FilterIdentifierForInvalidChars(result);
                StaticFieldIDs.Add(fieldSignature, result);
            }
            return result;
        }
        /// <summary>
        /// Retruns whether the specified static field has an ID yet or not.
        /// </summary>
        /// <param name="theField">The static field to get the ID of.</param>
        /// <returns>Whether the specified static field has an ID yet or not.</returns>
        public bool ContainsStaticFieldID(FieldInfo theField)
        {
            string fieldSignature = Utils.GetFieldSignature(theField);
            fieldSignature = "staticfield_" + Utils.FilterIdentifierForInvalidChars(fieldSignature);
            return StaticFieldIDs.ContainsKey(fieldSignature);
        }
        /// <summary>
        /// Gets the specified type's ID. If the type has not been scanned already, a new ID is created.
        /// </summary>
        /// <param name="theType">The type to get the ID of.</param>
        /// <returns>The type's ID.</returns>
        public string GetTypeID(Type theType)
        {
            string assemblyQualifiedName = theType.AssemblyQualifiedName;
            string result = Utils.GetMD5Hash(
                Encoding.UTF8.GetBytes(theType.AssemblyQualifiedName));
            if(TypeIDs.ContainsKey(assemblyQualifiedName))
            {
                result = TypeIDs[assemblyQualifiedName];
            }
            else
            {
                TypeIDs.Add(assemblyQualifiedName, result);
            }
            return result;
        }
        /// <summary>
        /// Retruns whether the specified type has an ID yet or not.
        /// </summary>
        /// <param name="theType">The type to get the ID of.</param>
        /// <returns>Whether the specified type has an ID yet or not.</returns>
        public bool ContainsTypeID(Type theType)
        {
            return TypeIDs.ContainsKey(theType.AssemblyQualifiedName);
        }
        /// <summary>
        /// Get's the Id string (assembler label) of the specified type ID.
        /// </summary>
        /// <param name="typeId">The type ID to convert to a label.</param>
        /// <returns>The ID string.</returns>
        public string GetTypeIdString(string typeId)
        {
            return Utils.FilterIdentifierForInvalidChars("type_" + typeId);
        }

        /// <summary>
        /// Adds a new string literal of specified value to the string literals data block.
        /// </summary>
        /// <param name="value">The value of the string to add.</param>
        /// <param name="ilOpInfo">The ILOpInfo that is adding the string literal.</param>
        /// <returns>The ID (label) of the string.</returns>
        public string AddStringLiteral(string value, ILOpInfo ilOpInfo)
        {
            string stringID = Utils.GetMD5Hash(
                Encoding.UTF8.GetBytes(value));
            string label = Utils.FilterIdentifierForInvalidChars("StringLiteral_" + stringID);
            
            if (!StringLiteralsDataBlock.ASM.ToString().Contains(stringID))
            {
                Encoding xEncoding = Encoding.ASCII;

                var NumBytes = xEncoding.GetByteCount(value);
                var stringData = new byte[4 + NumBytes];
                Array.Copy(BitConverter.GetBytes(value.Length), 0, stringData, 0, 4);
                Array.Copy(xEncoding.GetBytes(value), 0, stringData, 4, NumBytes);

                //This is UTF-16 (Unicode)/ASCII text
                StringLiteralsDataBlock.ASM.AppendLine(string.Format("{0}:", label));
                //Put in type info as FOS_System.String type
                StringLiteralsDataBlock.ASM.AppendLine("dd STRING_TYPE_ID");
                //Put in string length bytes
                StringLiteralsDataBlock.ASM.Append("db ");
                for (int i = 0; i < 3; i++)
                {
                    StringLiteralsDataBlock.ASM.Append(stringData[i]);
                    StringLiteralsDataBlock.ASM.Append(", ");
                }
                StringLiteralsDataBlock.ASM.Append(stringData[3]);
                //Put in string characters (as words)
                StringLiteralsDataBlock.ASM.Append("\ndw ");
                for (int i = 4; i < (stringData.Length - 1); i++)
                {
                    StringLiteralsDataBlock.ASM.Append(stringData[i]);
                    StringLiteralsDataBlock.ASM.Append(", ");
                }
                StringLiteralsDataBlock.ASM.Append(stringData.Last());
                StringLiteralsDataBlock.ASM.AppendLine();

                if (DebugBuild)
                {
                    DB_StringLiteral dbStringLiteral = new DB_StringLiteral();
                    dbStringLiteral.Id = stringID;
                    if (ilOpInfo != null)
                    {
                        dbStringLiteral.ILOpInfoID = ilOpInfo.DBILOpInfo.Id;
                    }
                    dbStringLiteral.Value = value;
                    DebugDatabase.AddStringLiteral(dbStringLiteral);
                }
            }

            return label;
        }
        /// <summary>
        /// Adds the specified static field to the static fields data block.
        /// </summary>
        /// <param name="aField">The field info to add.</param>
        /// <returns>The ID (label) of the static field.</returns>
        public string AddStaticField(FieldInfo aField)
        {
            //Don't add twice...
            string FieldID = null;
            if (!ContainsStaticFieldID(aField))
            {
                FieldID = GetStaticFieldID(aField);
                Type fieldType = aField.FieldType;
                int fieldSize = Utils.GetNumBytesForType(fieldType);
                StaticFieldsDataBlock.ASM.AppendLine(string.Format("{0}: times {1} db 0", FieldID, fieldSize));
            }
            else
            {
                FieldID = GetStaticFieldID(aField);
            }

            return FieldID;
        }
        
        /// <summary>
        /// A count of the total number of entries added to the Types Table.
        /// Used for allocating FOS_System.Type.Id numbers.
        /// </summary>
        private int TypesTable_TotalNumEntries = 0;
        /// <summary>
        /// Adds the specified type to the Types Table.
        /// </summary>
        /// <param name="TheDBType">The type to add.</param>
        public void AddType(DB_Type TheDBType)
        {
            //The structure of an entry in the Types Table must be the same as
            //the FOS_System.Type class

            string TypeId = GetTypeIdString(TheDBType.Id);
            string SizeVal = TheDBType.BytesSize.ToString();
            string IdVal = (TypesTable_TotalNumEntries++).ToString();
            string StackSizeVal = TheDBType.StackBytesSize.ToString();
            string IsValueTypeVal = (TheDBType.IsValueType ? "1" : "0");
            string MethodTablePointer = TypeId + "_MethodTable";
            string IsPointerTypeVal = (TheDBType.IsPointerType ? "1" : "0");
            string BaseTypeIdVal = "0";
            if (TheDBType.BaseTypeId != null)
            {
                BaseTypeIdVal = GetTypeIdString(TheDBType.BaseTypeId);
            }
            string FieldTablePointer = TypeId + "_FieldTable";
            string TypeSignatureLiteralLabel = AddStringLiteral(TheDBType.Signature, null);
            string TypeIdLiteralLabel = AddStringLiteral(TheDBType.Id, null);

            // We add the info in a presumed order
            //  It is rearranged into the correct order later in Finalise
            TypesTableDataBlock.ASM.AppendLine(string.Format("{0}|{1}|{2}|{3}|{4}|{5}|{6}|{7}|{8}|{9}|{10}|{11}",
                TypeId + ":", TheDBType.Signature, SizeVal, IdVal, StackSizeVal, IsValueTypeVal, MethodTablePointer,
                IsPointerTypeVal, BaseTypeIdVal, FieldTablePointer, TypeSignatureLiteralLabel, TypeIdLiteralLabel));
        }

        private long currentMethodTablePriorityOffset = (long.MaxValue / 2) + 1;
        /// <summary>
        /// Adds the methods of the specified type to the type table.
        /// </summary>
        /// <param name="TheType">The type to process.</param>
        public void AddTypeMethods(Type TheType)
        {
            string currentTypeId = GetTypeIdString(GetTypeID(TheType));
            ASMChunk methodTable = new ASMChunk();
            methodTable.SequencePriority = currentMethodTablePriorityOffset++;
            
            methodTable.ASM.AppendLine("; Method Table - " + TheType.FullName);
            methodTable.ASM.AppendLine(currentTypeId + "_MethodTable:");

            if (TheType.BaseType == null || TheType.BaseType.FullName != "System.Array")
            {
                MethodInfo[] OwnMethods = GetInstanceMethods(TheType);
                foreach (MethodInfo anOwnMethod in OwnMethods)
                {
                    if (!anOwnMethod.IsAbstract)
                    {
                        string methodID = GetMethodID(anOwnMethod);
                        string methodIDValue = GetMethodIDValue(anOwnMethod);
                        methodTable.ASM.AppendLine(methodIDValue + "|" + methodID);
                    }
                }
            }

            string parentTypeMethodTablePtr = "0";
            if (TheType.BaseType != null)
            {
                if (!TheType.BaseType.AssemblyQualifiedName.Contains("mscorlib"))
                {
                    parentTypeMethodTablePtr = GetTypeIdString(GetTypeID(TheType.BaseType)) + "_MethodTable";
                }
            }
            methodTable.ASM.AppendLine("0|" + parentTypeMethodTablePtr);

            methodTable.ASM.AppendLine("; Method Table End - " + TheType.FullName);

            MethodTablesDataBlock.Add(methodTable);
        }
        /// <summary>
        /// Returns all the instance (i.e. non-static) methods (including private methods) of the specified type excluding inherited methods.
        /// </summary>
        /// <param name="TheType">The type to get methods of.</param>
        /// <returns>All the instance methods.</returns>
        private MethodInfo[] GetInstanceMethods(Type TheType)
        {
            if (TheType.AssemblyQualifiedName.Contains("mscorlib"))
            {
                return new MethodInfo[0];
            }
            return TheType.GetMethods(BindingFlags.NonPublic | BindingFlags.DeclaredOnly | BindingFlags.Public | BindingFlags.Instance);
        }

        private long currentFieldTablePriorityOffset = (2 * (long.MaxValue / 3)) + 1;
        /// <summary>
        /// Adds the non-static fields of the specified type to the type table.
        /// </summary>
        /// <param name="TheType">The type to process.</param>
        public void AddTypeFields(Type TheType)
        {
            DB_Type objDBType = DebugDatabase.GetType(GetTypeID(TheType));
            
            string currentTypeId = GetTypeIdString(GetTypeID(TheType));
            ASMChunk fieldTable = new ASMChunk();
            fieldTable.SequencePriority = currentFieldTablePriorityOffset++;

            fieldTable.ASM.AppendLine("; Field Table - " + TheType.FullName);
            fieldTable.ASM.AppendLine(currentTypeId + "_FieldTable:");

            if (TheType.BaseType == null || (TheType.BaseType.FullName != "System.Array" && 
                                             TheType.BaseType.FullName != "System.MulticastDelegate"))
            {
                FieldInfo[] OwnFields = GetInstanceFields(TheType);
                foreach (FieldInfo anOwnField in OwnFields)
                {
                    List<DB_ComplexTypeLink> allChildLinks = objDBType.ChildTypes.OrderBy(x => x.ParentIndex).ToList();
                    DB_ComplexTypeLink theTypeLink = (from links in objDBType.ChildTypes
                                                      where links.FieldId == anOwnField.Name
                                                      select links).First();
                    allChildLinks = allChildLinks.Where(x => x.ParentIndex < theTypeLink.ParentIndex).ToList();
                    int offset = allChildLinks.Sum(x => x.ChildType.IsValueType ? x.ChildType.BytesSize : x.ChildType.StackBytesSize);
                    int size = theTypeLink.ChildType.IsValueType ? theTypeLink.ChildType.BytesSize : theTypeLink.ChildType.StackBytesSize;
                    string fieldOffsetVal = offset.ToString();
                    string fieldSizeVal = size.ToString();
                    string fieldTypeIdVal = GetTypeIdString(theTypeLink.ChildTypeID);

                    fieldTable.ASM.AppendLine(string.Format("{0}|{1}|{2}", 
                        fieldOffsetVal, fieldSizeVal, fieldTypeIdVal));
                }
            }

            string parentTypeFieldTablePtr = "0";
            if (TheType.BaseType != null)
            {
                if (!TheType.BaseType.AssemblyQualifiedName.Contains("mscorlib"))
                {
                    parentTypeFieldTablePtr = GetTypeIdString(GetTypeID(TheType.BaseType)) + "_FieldTable";
                }
            }
            fieldTable.ASM.AppendLine("0|0|" + parentTypeFieldTablePtr);

            fieldTable.ASM.AppendLine("; Field Table End - " + TheType.FullName);

            FieldTablesDataBlock.Add(fieldTable);
        }
        /// <summary>
        /// Returns all the instance (i.e. non-static) fields (including private fields) of the specified type excluding inherited fields.
        /// </summary>
        /// <param name="TheType">The type to get methods of.</param>
        /// <returns>All the instance methods.</returns>
        private FieldInfo[] GetInstanceFields(Type TheType)
        {
            if (TheType.AssemblyQualifiedName.Contains("mscorlib"))
            {
                return new FieldInfo[0];
            }
            return TheType.GetFields(BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public);
        }

        /// <summary>
        /// Initialises the string literals data block.
        /// </summary>
        private void InitStringLiteralsDataBlock()
        {
            StringLiteralsDataBlock.ASM.AppendLine("; BEGIN - String Literals");
            //Make them appear just before then end 
            // - not right at the end since the end file stuff has to go there
            //      (See ILScanner.Execute():endChunk)
            StringLiteralsDataBlock.SequencePriority = (long.MaxValue / 2) - 2;
        }
        /// <summary>
        /// Finalises the string literals data block (adds ending labels).
        /// </summary>
        public void FinaliseStringLiteralsDataBlock()
        {
            StringLiteralsDataBlock.ASM.AppendLine("; END - String Literals");

            StringLiteralsDataBlock.ASM.Replace("STRING_TYPE_ID", GetTypeIdString(GetTypeID(StringClass)));
        }

        /// <summary>
        /// Initialises the static fields data block.
        /// </summary>
        private void InitStaticFieldsDataBlock()
        {
            StaticFieldsDataBlock.ASM.AppendLine("; BEGIN - Static Fields");
            //Make them appear just before then end 
            // - not right at the end since the end file stuff has to go there
            //      (See ILScanner.Execute():endChunk)
            StaticFieldsDataBlock.SequencePriority = (long.MaxValue / 2) - 1;
        }
        /// <summary>
        /// Finalises the static fields data block (adds ending labels).
        /// </summary>
        public void FinaliseStaticFieldsDataBlock()
        {
            StaticFieldsDataBlock.ASM.AppendLine("; END - Static Fields");
        }

        /// <summary>
        /// Initialises the types tables data block.
        /// </summary>
        private void InitTypesTablesDataBlock()
        {
            TypesTableDataBlock.ASM.AppendLine("; BEGIN - Types Table");
            //Make them appear just before then end 
            // - not right at the end since the end file stuff has to go there
            //      (See ILScanner.Execute():endChunk)
            TypesTableDataBlock.SequencePriority = (long.MaxValue / 2) - 2;
        }
        /// <summary>
        /// Finalises the types table data block (adds ending labels and performs reprocessing).
        /// </summary>
        public void FinaliseTypesTablesDataBlock()
        {
            // Reprocess the types table to put fields into correct order

            // Pre-calculate the order translation table
            
            DB_Type typeDBType = DebugDatabase.GetType(GetTypeID(TypeClass));

            // + 2 because of type label and human readable label
            int offset = 2;
            int SizeOffset = GetFieldIndex(typeDBType, "Size") + offset;
            int IdOffset = GetFieldIndex(typeDBType, "Id") + offset;
            int StackSizeOffset = GetFieldIndex(typeDBType, "StackSize") + offset;
            int IsValueTypeOffset = GetFieldIndex(typeDBType, "IsValueType") + offset;
            int MethodTablePtrOffset = GetFieldIndex(typeDBType, "MethodTablePtr") + offset;
            int IsPointerOffset = GetFieldIndex(typeDBType, "IsPointer") + offset;
            int TheBaseTypeOffset = GetFieldIndex(typeDBType, "TheBaseType") + offset;
            int FieldTablePtrOffset = GetFieldIndex(typeDBType, "FieldTablePtr") + offset;
            int SignatureOffset = GetFieldIndex(typeDBType, "Signature") + offset;
            int IdStringOffset = GetFieldIndex(typeDBType, "IdString") + offset;

            int[] TranslationTable = new int[12];
            // Output index <- Origin index
            TranslationTable[0] = 0; //Type label
            TranslationTable[1] = 1; //Human readable label
            TranslationTable[SizeOffset] = 2;
            TranslationTable[IdOffset] = 3;
            TranslationTable[StackSizeOffset] = 4;
            TranslationTable[IsValueTypeOffset] = 5;
            TranslationTable[MethodTablePtrOffset] = 6;
            TranslationTable[IsPointerOffset] = 7;
            TranslationTable[TheBaseTypeOffset] = 8;
            TranslationTable[FieldTablePtrOffset] = 9;
            TranslationTable[SignatureOffset] = 10;
            TranslationTable[IdStringOffset] = 11;

            string[] PrefixesTable = new string[TranslationTable.Length];
            PrefixesTable[0] = ""; //Type label
            PrefixesTable[1] = "; "; //Human readable label
            PrefixesTable[SizeOffset] = "dd ";
            PrefixesTable[IdOffset] = "dd ";
            PrefixesTable[StackSizeOffset] = "dd ";
            PrefixesTable[IsValueTypeOffset] = "db ";
            PrefixesTable[MethodTablePtrOffset] = "dd ";
            PrefixesTable[IsPointerOffset] = "db ";
            PrefixesTable[TheBaseTypeOffset] = "dd ";
            PrefixesTable[FieldTablePtrOffset] = "dd ";
            PrefixesTable[SignatureOffset] = "dd ";
            PrefixesTable[IdStringOffset] = "dd ";
 
            List<string> entries = TypesTableDataBlock.ASM.ToString().Split("\n".ToCharArray(), StringSplitOptions.RemoveEmptyEntries).ToList();
            string beginLine = entries[0];
            entries.RemoveAt(0);
            TypesTableDataBlock.ASM.Clear();
            TypesTableDataBlock.ASM.AppendLine(beginLine.Trim());
            foreach (string anEntry in entries)
            {
                string[] parts = anEntry.TrimEnd().Split("|".ToCharArray(), StringSplitOptions.RemoveEmptyEntries);
                string finalEntry = "";
                for (int i = 0; i < TranslationTable.Length; i++)
                {
                    finalEntry += PrefixesTable[i] + parts[TranslationTable[i]] + "\n";
                }
                TypesTableDataBlock.ASM.AppendLine(finalEntry);
            }

            TypesTableDataBlock.ASM.AppendLine("; END - Types Table");
        }
        /// <summary>
        /// Finalises the method tables data blocks (performs reprocessing).
        /// </summary>
        public void FinaliseMethodTables()
        {
            // Reprocess the types table to put fields into correct order

            DB_Type typeDBType = DebugDatabase.GetType(GetTypeID(MethodInfoStruct));
            int offset = 0;
            int MethodIDOffset = GetFieldIndex(typeDBType, "MethodID") + offset;
            int MethodPtrOffset = GetFieldIndex(typeDBType, "MethodPtr") + offset;

            int[] TranslationTable = new int[2];
            // Output index <- Origin index
            TranslationTable[MethodIDOffset] = 0;
            TranslationTable[MethodPtrOffset] = 1;

            string[] PrefixesTable = new string[TranslationTable.Length];
            PrefixesTable[MethodIDOffset] = "dd ";
            PrefixesTable[MethodPtrOffset] = "dd ";

            foreach (ASMChunk aChunk in MethodTablesDataBlock)
            {
                List<string> entries = aChunk.ASM.ToString().Split("\n".ToCharArray(), StringSplitOptions.RemoveEmptyEntries).ToList();
                
                string beginLine1 = entries[0];
                string beginLine2 = entries[1];
                string endLine1 = entries.Last();
                entries.RemoveAt(1);
                entries.RemoveAt(0);
                entries.RemoveAt(entries.Count - 1);

                aChunk.ASM.Clear();
                aChunk.ASM.AppendLine(beginLine1.Trim());
                aChunk.ASM.AppendLine(beginLine2.Trim());

                foreach (string anEntry in entries)
                {
                    string[] parts = anEntry.TrimEnd().Split("|".ToCharArray(), StringSplitOptions.RemoveEmptyEntries);
                    string finalEntry = "";
                    for (int i = 0; i < TranslationTable.Length; i++)
                    {
                        finalEntry += PrefixesTable[i] + parts[TranslationTable[i]] + "\n";
                    }
                    aChunk.ASM.AppendLine(finalEntry);
                }

                aChunk.ASM.AppendLine(endLine1.Trim());
            }
        }
        /// <summary>
        /// Finalises the field tables data blocks (performs reprocessing).
        /// </summary>
        public void FinaliseFieldTables()
        {
            // Reprocess the types table to put fields into correct order

            DB_Type typeDBType = DebugDatabase.GetType(GetTypeID(FieldInfoStruct));
            int offset = 0;
            int OffsetOffset = GetFieldIndex(typeDBType, "Offset") + offset;
            int SizeOffset = GetFieldIndex(typeDBType, "Size") + offset;
            int FieldTypeOffset = GetFieldIndex(typeDBType, "FieldType") + offset;

            int[] TranslationTable = new int[3];
            // Output index <- Origin index
            TranslationTable[OffsetOffset] = 0;
            TranslationTable[SizeOffset] = 1;
            TranslationTable[FieldTypeOffset] = 2;

            string[] PrefixesTable = new string[TranslationTable.Length];
            PrefixesTable[OffsetOffset] = "dd ";
            PrefixesTable[SizeOffset] = "dd ";
            PrefixesTable[FieldTypeOffset] = "dd ";

            foreach (ASMChunk aChunk in FieldTablesDataBlock)
            {
                List<string> entries = aChunk.ASM.ToString().Split("\n".ToCharArray(), StringSplitOptions.RemoveEmptyEntries).ToList();

                string beginLine1 = entries[0];
                string beginLine2 = entries[1];
                string endLine1 = entries.Last();
                entries.RemoveAt(1);
                entries.RemoveAt(0);
                entries.RemoveAt(entries.Count - 1);

                aChunk.ASM.Clear();
                aChunk.ASM.AppendLine(beginLine1.Trim());
                aChunk.ASM.AppendLine(beginLine2.Trim());

                foreach (string anEntry in entries)
                {
                    string[] parts = anEntry.TrimEnd().Split("|".ToCharArray(), StringSplitOptions.RemoveEmptyEntries);
                    string finalEntry = "";
                    for (int i = 0; i < TranslationTable.Length; i++)
                    {
                        finalEntry += PrefixesTable[i] + parts[TranslationTable[i]] + "\n";
                    }
                    aChunk.ASM.AppendLine(finalEntry);
                }

                aChunk.ASM.AppendLine(endLine1.Trim());
            }
        }

        /// <summary>
        /// Gets the index of a field in the specified type.
        /// </summary>
        /// <param name="dbType">The type to look for the field in.</param>
        /// <param name="fieldName">The name of the field to look for.</param>
        /// <returns>Returns the index.</returns>
        private int GetFieldIndex(DB_Type dbType, string fieldName)
        {
            //Get the child links of the type (i.e. the fields of the type)
            List<DB_ComplexTypeLink> allChildLinks = dbType.ChildTypes.OrderBy(x => x.ParentIndex).ToList();
            //Get the DB type information for the field we want to load
            DB_ComplexTypeLink theTypeLink = (from links in dbType.ChildTypes
                                              where links.FieldId == fieldName
                                              select links).First();
            //Get all the fields that come before the field we want to load
            //This is so we can calculate the offset (in memory, in bytes) from the start of the object
            allChildLinks = allChildLinks.Where(x => x.ParentIndex < theTypeLink.ParentIndex).ToList();
            //Calculate the offset
            return allChildLinks.Count();
        }

        /// <summary>
        /// Finalises the IL scanner state so the IL scanner is ready for use in an ASM sequencer.
        /// </summary>
        public void Finalise()
        {
            FinaliseStringLiteralsDataBlock();
            FinaliseStaticFieldsDataBlock();
            FinaliseTypesTablesDataBlock();
            FinaliseMethodTables();
            FinaliseFieldTables();
        }
    }
    /// <summary>
    /// Represents a stack frame.
    /// </summary>
    public class StackFrame
    {
        /// <summary>
        /// The stack of items in the current stack frame.
        /// </summary>
        public Stack<StackItem> Stack = new Stack<StackItem>();
    }
    /// <summary>
    /// Represents an item on a stack.
    /// </summary>
    public class StackItem
    {
        /// <summary>
        /// The size of the item (in bytes) on the stack.
        /// </summary>
        public int sizeOnStackInBytes;
        /// <summary>
        /// Whether the item represents a floating point number (single or double precision).
        /// </summary>
        public bool isFloat;

        /// <summary>
        /// Whether the item on the stack is actually a pointer to an object
        /// that has just been created by a NewObj IL op.
        /// </summary>
        /// <remarks>
        /// Used for correctly decrementing / incrementing GC ref count
        /// when a new object is created and either stored or the reference
        /// is popped off the stack.
        /// </remarks>
        public bool isNewGCObject = false;
    }
    /// <summary>
    /// Represents a local variable.
    /// </summary>
    public class LocalVariable : StackItem
    {
        /// <summary>
        /// The type of the local variable.
        /// </summary>
        public Type TheType;
    }
}
