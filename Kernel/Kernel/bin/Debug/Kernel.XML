<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Kernel</name>
    </assembly>
    <members>
        <member name="T:Kernel.Debug.BasicDebug">
            <summary>
            The basic kernel debugger code.
            </summary>
            <remarks>
            This is entirely made from plugged methods so that even if the 
            kernel compiler is broken, the debugger will still work.
            </remarks>
        </member>
        <member name="M:Kernel.Debug.BasicDebug.Init">
            <summary>
            Initialises the basic debugger
            </summary>
        </member>
        <member name="M:Kernel.Debug.BasicDebug.InitSerial">
            <summary>
            Initialises COM1 as serial connection to debug over
            </summary>
        </member>
        <member name="M:Kernel.Debug.BasicDebug.BeginEnableDebug">
            <summary>
            Begins enabling the debug interrupt handler
            </summary>
        </member>
        <member name="M:Kernel.Debug.BasicDebug.EndEnableDebug">
            <summary>
            Ends enabling the debug interrupt handler
            </summary>
        </member>
        <member name="M:Kernel.Debug.BasicDebug.Int3">
            <summary>
            Invokes interrupt 3.
            </summary>
        </member>
        <member name="M:Kernel.Debug.BasicDebug.Execute">
            <summary>
            The main execute method for the basic debugger
            </summary>
        </member>
        <member name="M:Kernel.Debug.BasicDebug.InsertCommandsList">
            <summary>
            Inserts the debug commands into the ASM.
            </summary>
        </member>
        <member name="M:Kernel.Debug.BasicDebug.SendBreakCmd">
            <summary>
            Sends the Break command.
            </summary>
        </member>
        <member name="M:Kernel.Debug.BasicDebug.SendBreakAddress">
            <summary>
            Sends the address of the last instruction that executed when the 
            break occurred.
            </summary>
        </member>
        <member name="M:Kernel.Debug.BasicDebug.SendRegisters">
            <summary>
            Sends the register values as they were before the interrupt.
            </summary>
        </member>
        <member name="M:Kernel.Debug.BasicDebug.SendArguments">
            <summary>
            Sends the arguments values as they were before the interrupt.
            Requires the debugger to send it how many bytes for 
            the arguments there are.
            </summary>
        </member>
        <member name="M:Kernel.Debug.BasicDebug.SendLocals">
            <summary>
            Sends the locals values as they were before the interrupt.
            Requires the debugger to send it how many bytes for 
            the arguments there are.
            </summary>
        </member>
        <member name="M:Kernel.Debug.BasicDebug.WaitForCommand">
            <summary>
            Waits for a command from the debugger.
            </summary>
        </member>
        <member name="M:Kernel.Debug.BasicDebug.Serial_WriteByte(System.Byte)">
            <summary>
            Writes the specified value to the debug serial port. Not callable from C#.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:Kernel.Debug.BasicDebug.Serial_WriteUInt16(System.UInt16)">
            <summary>
            Writes the specified value to the debug serial port. Not callable from C#.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:Kernel.Debug.BasicDebug.Serial_WriteUInt32(System.UInt32)">
            <summary>
            Writes the specified value to the debug serial port. Not callable from C#.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:Kernel.Debug.BasicDebug.Serial_WriteString(System.String)">
            <summary>
            Writes the specified value to the debug serial port. Not callable from C#.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:Kernel.Debug.BasicDebug.Serial_ReadByte">
            <summary>
            Reads a byte from the debug serial port. Not callable from C#.
            </summary>
            <returns>The byte read.</returns>
        </member>
        <member name="M:Kernel.Debug.BasicDebug.Serial_ReadUInt16">
            <summary>
            Reads a UInt16 from the debug serial port. Not callable from C#.
            </summary>
            <returns>The UInt16 read.</returns>
        </member>
        <member name="M:Kernel.Debug.BasicDebug.Serial_ReadUInt32">
            <summary>
            Reads a UInt32 from the debug serial port. Not callable from C#.
            </summary>
            <returns>The UInt32 read.</returns>
        </member>
        <member name="M:Kernel.Debug.BasicDebug.Serial_SafeReadUInt32">
            <summary>
            Safely reads a UInt32 from the debug serial port
            </summary>
            <returns>The UInt32 read.</returns>
        </member>
        <member name="M:Kernel.Debug.BasicDebug.InterruptHandler">
            <summary>
            Inserts the plug for the Int1 and Int3 interrupt handler.
            </summary>
        </member>
        <member name="T:Kernel.Paging">
            <summary>
            Provides methods for setting up paged virtual memory.
            </summary>
        </member>
        <member name="F:Kernel.Paging.LoadedPaging">
            <summary>
            Whether paging has been loaded or not.
            </summary>
        </member>
        <member name="M:Kernel.Paging.Init">
            <summary>
            Initializes paged virtual memory.
            </summary>
        </member>
        <member name="M:Kernel.Paging.LoadPaging">
            <summary>
            Loads paged virtual memory.
            </summary>
        </member>
        <member name="M:Kernel.Paging.InitKernelPages">
            <summary>
            Initializes the pages that cover the kernel's memory.
            </summary>
        </member>
        <member name="M:Kernel.Paging.EnablePaging">
            <summary>
            Enables paging.
            </summary>
        </member>
        <member name="M:Kernel.Paging.GetPageDirectoryPtr">
            <summary>
            Gets the page directory memory pointer.
            </summary>
            <returns>The pointer.</returns>
        </member>
        <member name="M:Kernel.Paging.GetFirstPageTablePtr">
            <summary>
            Gets a pointer to the page table that is the first page table.
            </summary>
            <returns>The pointer.</returns>
        </member>
        <member name="M:Kernel.Paging.GetKernelPageTablePtr">
            <summary>
            Gets a pointer to the page table that covers the kernel's memory.
            </summary>
            <returns>The pointer.</returns>
        </member>
        <member name="M:Kernel.Paging.GetKernelMemStartPtr">
            <summary>
            Gets a pointer to the start of the kernel in memory.
            </summary>
            <returns>The pointer.</returns>
        </member>
        <member name="M:Kernel.Paging.GetKernelMemEndPtr">
            <summary>
            Gets a pointer to the end of the kernel in memory.
            </summary>
            <returns>The pointer.</returns>
        </member>
        <member name="T:Kernel.PreReqs">
            <summary>
            Contains plugged methos that are pre-requisites for the kernel to boot.
            For example, the Multiboot Signature.
            </summary>
        </member>
        <member name="M:Kernel.PreReqs.MultibootSignature">
            <summary>
            Inserts the multiboot signature at the start of the file.
            </summary>
        </member>
        <member name="M:Kernel.PreReqs.Kernel_Start">
            <summary>
            Inserts the pre-entrypoint kernel start method plug.
            </summary>
        </member>
        <member name="M:Kernel.PreReqs.InitStack">
            <summary>
            Inserts the initialise stack code. 
            Kernel stack space is currently hard-coded into the 
            Multiboot Signature asm.
            </summary>
        </member>
        <member name="M:Kernel.PreReqs.InitGDT">
            <summary>
            Initialises the Global Descriptor Table.
            </summary>
        </member>
        <member name="M:Kernel.PreReqs.InitIDT">
            <summary>
            Initialises the Interrupt Descriptor Table.
            </summary>
        </member>
        <member name="M:Kernel.PreReqs.SSEInit">
            <summary>
            Initialises CPU SSE commands (i.e. allows them to be used).
            </summary>
        </member>
        <member name="M:Kernel.PreReqs.MainEntrypoint">
            <summary>
            Inserts the stub that calls the main kernel entrypoint.
            </summary>
        </member>
        <member name="M:Kernel.PreReqs.Reset">
            <summary>
            Resets the OS / CPU / etc. i.e. terminates the OS
            </summary>
        </member>
        <member name="M:Kernel.PreReqs.HandleNoMultiboot">
            <summary>
            Inserts the method that handles what happens when the Multiboot
            Signature is invalid or undetected.
            </summary>
        </member>
        <member name="M:Kernel.PreReqs.WriteDebugVideo(System.String,System.UInt32)">
            <summary>
            Writes a piece of text to the first line of the screen. Note: Does not use same string memory structure as C# so cannot be called
            from C#. Uses format of: Length as DWORD, Characters as BYTE
            </summary>
            <param name="aText">The text to write. First dword should be the length of the string. (Inserted by compiler for string literals)</param>
            <param name="aColour">The foreground/background (DOS) colour to write in - 0xXY where X is background colour and Y is foreground colour.</param>
        </member>
        <member name="T:Kernel.Kernel">
            <summary>
            The main class (containing the kernel entry point) for the Fling OS kernel.
            </summary>
        </member>
        <member name="M:Kernel.Kernel.#cctor">
            <summary>
            Initialises static stuff within the kernel (such as calling GC.Init and BasicDebug.Init)
            </summary>
        </member>
        <member name="M:Kernel.Kernel.CallStaticConstructors">
            <summary>
            Filled-in by the compiler.
            </summary>
        </member>
        <member name="M:Kernel.Kernel.Main">
            <summary>
            Main kernel entry point
            </summary>
        </member>
        <member name="M:Kernel.Kernel.Halt">
            <summary>
            Halts the kernel and halts the CPU.
            </summary>
        </member>
        <member name="F:Kernel.Kernel.disk0">
            <summary>
            Disk0 - expected to be the primary, master HDD.
            </summary>
        </member>
        <member name="M:Kernel.Kernel.ManagedMain">
            <summary>
            The actual main method for the kernel - by this point, all memory management, exception handling 
            etc has been set up properly.
            </summary>
        </member>
        <member name="M:Kernel.Kernel.OutputCurrentExceptionInfo">
            <summary>
            Outputs the current exception information.
            </summary>
        </member>
        <member name="M:Kernel.Kernel.InitPCI">
            <summary>
            Initialises PCI sub-system.
            </summary>
        </member>
        <member name="M:Kernel.Kernel.InitATA">
            <summary>
            Intialises the ATA sub-system.
            </summary>
        </member>
        <member name="M:Kernel.Kernel.InitFileSystem">
            <summary>
            Initialises the file-system.
            </summary>
        </member>
        <member name="M:Kernel.Kernel.CheckDiskFormatting">
            <summary>
            Checks for usable FAT32 partitions. If none found, formats "disk0" as MBR, 1 FAT32 partiton.
            </summary>
        </member>
        <member name="M:Kernel.Kernel.InitUSB">
            <summary>
            Initialises USB sub-system.
            </summary>
        </member>
        <member name="M:Kernel.Kernel.OutputFileSystemsInfo">
            <summary>
            Outputs file systems info (including listings for the A:/ drive)
            </summary>
        </member>
        <member name="M:Kernel.Kernel.OutputListings(Kernel.FOS_System.Collections.List)">
            <summary>
            Outputs specified listings.
            </summary>
            <param name="Listings">The listings to output.</param>
        </member>
        <member name="M:Kernel.Kernel.OutputFileContents(Kernel.FOS_System.String)">
            <summary>
            Outputs the content of the specified file as ASCII text.
            </summary>
            <param name="fileName">The file to output.</param>
        </member>
        <member name="M:Kernel.Kernel.OutputDirectoryContents(Kernel.FOS_System.String)">
            <summary>
            Outputs the contents of the specified directory as a list of files and sub-directories.
            </summary>
            <param name="dir">The directory to output.</param>
        </member>
        <member name="M:Kernel.Kernel.OutputDivider">
            <summary>
            Outputs a divider line.
            </summary>
        </member>
        <member name="M:Kernel.Kernel.OutputPCIInfo">
            <summary>
            Outputs PCI information.
            </summary>
        </member>
        <member name="M:Kernel.Kernel.OutputATAInfo">
            <summary>
            Outputs information about the ATA devices found.
            </summary>
        </member>
        <member name="M:Kernel.Kernel.FileSystemTests">
            <summary>
            Runs a series of tests on the file system, currently:
             - Finds or creates A:/ drive
             - Attempts to use FAT file system for A drive
             - Finds or creates a folder called "P1D2"
             - Finds or creates short and long name files in "P1D2"
             - Writes and reads from above test files.
            </summary>
        </member>
        <member name="M:Kernel.Kernel.ULongLTComparisonTest">
            <summary>
            Tests unsigned less-than comparison of ulongs.
            </summary>
        </member>
        <member name="M:Kernel.Kernel.ULongMultiplicationTest">
            <summary>
            Tests multiplying two 64-bit numbers together
            </summary>
        </member>
        <member name="M:Kernel.Kernel.StringConcatTest">
            <summary>
            Tests dynamic string creation and string concatentation.
            </summary>
        </member>
        <member name="M:Kernel.Kernel.ObjectArrayTest">
            <summary>
            Tests creating arrays where elements are reference-type and Gc managed.
            </summary>
        </member>
        <member name="M:Kernel.Kernel.IntArrayTest">
            <summary>
            Tests creating an array of integers (element of type from MSCorLib type and value type)
            </summary>
        </member>
        <member name="M:Kernel.Kernel.DummyObjectTest">
            <summary>
            Tests creating  GC-managed reference-type object and  setting properties and enums.
            </summary>
        </member>
        <member name="M:Kernel.Kernel.DivideByZeroTest">
            <summary>
            Tests managed exception sub-system by deliberately causing hardware-level divide-by-zero exception.
            </summary>
        </member>
        <member name="M:Kernel.Kernel.ExceptionsTestP1">
            <summary>
            Tests the exception handling sub-system.
            </summary>
            <remarks>
            If the mechanism appears to work but code in Main() stops working then
            it is because one of the GC methods is calling a method / get-set property
            that is not marked with [Comnpiler.NoGC]. Make sure all methods that the 
            GC calls are marked with [Compiler.NoGC] attribute. See example.
            </remarks>
            <example>
            public int x
            {
                [Compiler.NoGC]
                get
                {
                    return 0;
                }
            }
            </example>
        </member>
        <member name="M:Kernel.Kernel.ExceptionsTestP2">
            <summary>
            Secondary method used in testing the exception handling sub-system.
            </summary>
        </member>
    </members>
</doc>
