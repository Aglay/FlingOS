using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.IO;
using System.Globalization;

namespace Kernel.Debug.Data
{
    /// <summary>
    /// Used to access data from the .map file generated by Cygwin\ObjDump.exe
    /// </summary>
    public class ElfMap
    {
        /// <summary>
        /// The minimum loaded address. Used in nearest label searching to reduce search time.
        /// </summary>
        ulong minAddress = ulong.MaxValue;
        
        /// <summary>
        /// The underlying map dictionary that maps addresses to labels
        /// </summary>
        Dictionary<ulong, List<string>> Map = new Dictionary<ulong, List<string>>();
        
        /// <summary>
        /// Initialises a new elf map and opens the specified map file.
        /// </summary>
        /// <param name="mapFileName">The map file to open.</param>
        public ElfMap(string mapFileName)
        {
            ReadFile(mapFileName);
        }

        /// <summary>
        /// Reads the specified file as an elf map file.
        /// </summary>
        /// <param name="fileName">The file to read.</param>
        private void ReadFile(string fileName)
        {
            StreamReader reader = new StreamReader(fileName);
            string currLine = "";
            bool FoundTableStart = false;
            while ((currLine = reader.ReadLine()) != null)
            {
                if (string.IsNullOrWhiteSpace(currLine))
                {
                    //Skip empty lines
                    continue;
                }

                currLine = currLine.Trim();

                if (!FoundTableStart)
                {
                    //Search till we find the start of the table
                    if(currLine == "SYMBOL TABLE:")
                    {
                        FoundTableStart = true;
                    }
                    continue;
                }

                //The symbol table has a standard format so go look at it 
                //and you'll see (or can count) these indices
                if(currLine.Length < 33)
                {
                    //Ignore lines that are too short i.e. not valid entries
                    continue;
                }
                string addressStr = currLine.Substring(0, 8);
                string sectionStr = currLine.Substring(17, 5);
                string labelStr = currLine.Substring(32);

                if(sectionStr != ".text" && sectionStr != ".data")
                {
                    //We are not interested in addresses / info about non-text or non-data sections
                    continue;
                }
                if(sectionStr == labelStr)
                {
                    //We get a label entry for sections...so just ignore them
                    continue;
                }

                ulong lineAddress;
                lineAddress = ulong.Parse(addressStr, NumberStyles.HexNumber);
                if(!Map.ContainsKey(lineAddress))
                {
                    Map.Add(lineAddress, new List<string>());
                }
                Map[lineAddress].Add(labelStr);

                if(lineAddress < minAddress)
                {
                    minAddress = lineAddress;
                }
            }
        }

        /// <summary>
        /// Determines whether the map contains exactly the specified address
        /// </summary>
        /// <param name="address">The address to look for.</param>
        /// <returns>Whether the map contains exactly the specified address or not.</returns>
        public bool ContainsExactAddress(ulong address)
        {
            return Map.ContainsKey(address);
        }

        /// <summary>
        /// Gets the labels that are at or the nearest before the specified address.
        /// </summary>
        /// <param name="address">The address to get the nearest labels for.</param>
        /// <returns>The nearest labels.</returns>
        /// <remarks>
        /// Multiple labels per a given address can mean more than 1 label returned.
        /// </remarks>
        public List<string> GetNearestLabels(ulong address)
        {
            List<string> result = new List<string>();

            for (ulong i = address; i >= minAddress; i--)
            {
                if(Map.ContainsKey(i))
                {
                    result = Map[i];
                    break;
                }
            }

            return result;
        }

        /// <summary>
        /// gets the address of the specified label or returns UInt.MaxValue 
        /// if label not found.
        /// </summary>
        /// <param name="label">The label to get the address of.</param>
        /// <returns>The address of the label.</returns>
        public ulong GetAddress(string label)
        {
            ulong result = ulong.MaxValue;

            var potAddresses = (from labels in Map
                                 where labels.Value.Contains(label)
                                 select labels.Key);

            if(potAddresses.Count() > 0)
            {
                result = potAddresses.First();
            }

            return result;
        }
    }
}
